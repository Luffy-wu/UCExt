Python is designed so that there really isn't that much to learn in the basic language. For example, it has

only one basic structure for conditional programming (if/else/elif)
two looping commands (while and for)
a consistent method of handling errors (try/except)
But the language's simplicity doesn't make it inflexible and weak. It simply means that you're not confronted with an overwhelming choice of options at every turn, and that makes programming a much simpler task.

Object Orientation

Python is a true object-oriented language. The term "object oriented" has become a buzzword, and high-profile languages such as C++ and Java are object oriented by design. Many other languages add some object-oriented capabilities but are not designed to be object oriented from the ground up, as Python is.

I'll talk about object orientation in Python in more detail in Modules 3 and 10, but for now, it's good to know why this feature is important. Object-oriented programming allows you to focus on the data you're interested in, whether it's employee information, the results of a scientific experiment or survey, the contents of your CD collection, or information entered by an Internet user into a shopping cart. It allows you to develop methods to deal efficiently with your data.

Modules

Python relies on modules -- self-contained programs that define a variety of functions and data types. When you want to do tasks beyond the scope of the basic core language, you can call modules by using the import command. For example, the core distribution of Python contains modules for

processing files
accessing your computer's operating system and the Internet
writing CGI scripts (which handle communicating with pages displayed in Web browsers)
string handling
many other tasks
Optional modules, available at Python.org, can be used to create graphical user interfaces, communicate with databases, process image files, and so on. This structure makes it easy to get started with Python because you can learn specific skills only as you need them. Python also runs more efficiently when you don't include every capability in every program.

Variables and Assignments

Like many other programming languages, Python uses the equal sign (=) to assign a value to a variable.

Variable names in Python are case sensitive and can contain letters, numbers, and the underscore character (_), although they cannot begin with a number.

You never need to declare variables in Python before you use them; Python figures out what type a variable is by its context.

When you assign a value to a variable you've used previously, the previous value is overwritten. The del operator can be used to completely remove any trace of a variable; using a variable after you've used the del operator will generate an error.

To assign a number to a variable, you can just use the number's value. To assign a string to a variable, you can surround it with single or double quotes. Here are some examples:

x = 5

y = 7

dept = 'Ministry of Silly Walks'
Indentation

Python provides you with a fair amount of freedom in composing statements, but there are a few rules to follow. Unlike most languages, Python uses indentation to signal the beginning and end of blocks of your programs. For example,

Python 3.0 (r30:67507, Dec 3 2008, 20:14:27) [MSC v.1500 32  bit (Intel)] on win32
Type "copyright", "credits" or "license()" for  more information.

****************************************************************
Personal firewall software may warn about the connection  IDLE
makes to its subprocess using this computer's internal  loopback
interface. This connection is not visible on any  external
interface and no data is sent to or received from the  Internet.
****************************************************************
  
IDLE 3.0

>>> price = 75.00
>>> tax = .075
>>> price * tax
5.625 
>>> print("Python is easy")
Python is easy
>>> language = "Python"
>>> for i in language:
... print(i)
P
y
t
h
o
n
At the end of the session, a for loop to print each individual letter of the variable called language is executed. The statement that is the body of the loop (print i) is indented from the remainder of the program.

When you use Python interactively to enter statements that need to be indented, the program provides three dots (...) as an input prompt instead of the usual three angle brackets (>>>). Also, when you're composing a file containing a Python program, you need to consistently indent the body of any loops you create. In either case, statements that are not indented must begin in column 1.

As an alternative to running Python interactively, you can use an editor of your choice to create a file containing your Python program and then execute it. Editors like emacs, vim, and the editor contained in the IDLE environment are smart about Python's indentation rules and will help you correctly compose your programs.

No matter how carefully you write your programs, errors will occur. Python has a consistent way to deal with them; it "raises an exception" and sends a signal to the program that tells it to stop.

If the story ended there, Python's error handling wouldn't be very noteworthy. But anytime you see an error message that was generated by Python, you can use a try/except clause to trap the error and process it any way you like. Without this kind of error handling, programmers must spend a great deal of time explaining how the various components of a program will inform the rest of the program that an error has occurred -- and how to deal with errors that are generated by other parts of the program.

As a simple example, consider the act of dividing by zero. In many computer languages (Python included), a program that divides by zero will generate an error message, possibly terminating the program's execution. Here's an example of what happens in Python:

>>> y = 5./0.
Traceback (most recent call last):
File "<stdin>", line 1, in ?
ZeroDivisionError: float division 
In the interpreter, you're simply prompted for another Python statement, but if such a division occurs inside a program, the program will terminate. Suppose you want to set the result of a division by zero to 0 and print a message to that effect. Using the try/except clause, that is very easy to do:

>>>  try:
...y = 5/0
except ZeroDivisionError:
...y = 0
...print('y set to zero due to division by zero.')
...
y set to zero due to division by zero.
The name in the except clause matches the name of the error that was printed in the default error message. Thus, any error message can be suppressed, and execution of the program would resume right after the body of the try/except clause.

Python was designed foremost as an interactive language. When you're using Python's interactive mode, statements are executed once you type them in, and the results of expressions you type are immediately printed.

On UNIX systems, you can type "python" at the UNIX prompt to enter the basic Python interpreter.
Under Windows or UNIX, you can use the Integrated Development environment known as "IDLE" to easily access Python.
You can terminate your interactive session with an end-of-file character.

Running a Python Program under Windows

The easiest way to run a Python program under Windows is to use the IDLE program editor to create a file with a ".py" extension.

You can navigate to IDLE by going to the IDLE entry of the Python submenu in the Programs folder of your Start menu. You can find the idle.pyw program and execute it directly. When IDLE starts up, it presents you with a "Python shell" into which you can interactively type Python commands.

Alternatively, you can use IDLE's editor to create a file containing your Python program. Once you've created and saved a file under IDLE, you can then click on the icon for that file (which should be a smiling Python) to execute the program.

If your Python program produces any printed output, a window will open, display the output, and immediately disappear.

Running a Python Program under UNIX

A standard technique for running programs written in a language such as Python on a UNIX system is to include a special line at the beginning of your programming that informs the operating system where it can find the Python interpreter. So, the first line in your Python program should look like this:

#!/usr/bin/env python

After placing the above line in your program, you need to mark the file as executable with the following command:

chmod +x filename

where filename is the name of the file containing your Python program. Now you can execute your program by simply typing its name at the UNIX prompt.

----- 2

Strings are a collection of characters that are stored together to represent arbitrary text. In Python, you can create string constants by surrounding text with any of these types of quotation marks:

single quotes (')
double quotes (")
a set of three of either type of quotes (''' or """)
When you use triple quotes, you can extend strings over several lines. With the other types of quotes, strings must be contained on a single line, or a backslash (\) must be appended to every line of the string except the last.

Here are a couple of examples of assigning string constants to variables:

name = "Fred Flintstone"

and

message = """A long character string, spanning several lines
can be stored (with its linebreaks) in a triple-quoted string.
This is especially handy for help messages stored inside a
program"""

Strings in Python are said to be immutable; that is, you can't change the elements of a string in place. When you want to modify a string, you must create a new string that contains the modifications you desire.

Special Character Sequences

Certain sequences of characters have special meanings inside quoted strings. These sequences begin with a backslash (\) and are listed in the following table:

Sequence
Character
\b
backspace
\t
horizontal tab
\v
vertical tab
\n
newline
\a
bell
\f
formfeed
\r
carriage return
\0
null terminator
\0nn
octal escape sequence for ASCII character
\xnn
hexadecimal escape sequence for ASCII character
\e
escape character
\'
single quote (used inside a single quoted string)
\"
double quote (used inside of a double quoted string)
\\
literal backslash (a backslash will appear in the string)
There are certain situations when you will want these character sequences to be interpreted literally, that is, without the special meanings listed in the table. For example, slashes must be used literally to construct regular expressions that are used for finding patterns in text. In cases like this, you can precede the initial quote character with the letter r, an abbreviation for raw string. Consider this short interactive Python session:

>>> print('The \n is the newline character')
The 
is the newline character
>>> print(r'The \n is the newline character')
The \n is the newline character

In the first case, the character sequence was interpreted as a newline -- it did not literally appear in the output. In the second case, because of the initial r, each character in the string is interpreted literally.

Concatenation

The addition operator (+) is used as a concatenation operator for character strings.

>>> one = 'black'
>>> two = 'jack'
>>> print(one + two)
blackjack

Repetition

The asterisk (*) serves as a repetition operator for strings. You can either have a number followed by the asterisk and then the string, or start with a string and follow with an asterisk and a number. In either case, the result is a new string with the old string repeated as many times as the number you specified. Thus, both of the following sequences produce a string containing ten dashes:

>>> '-' * 10
'----------'

and

>>> 10 * '-'
'----------'

You can freely mix literal strings and variables when you are manipulating strings. This makes it very easy to produce customized messages.

>>> print(msg + email)
Send me email.
My address is me@mydomain.com
>>> print(msg + "me@mydomain.com")
Send me email.
My address is me@mydomain.com 
Remember that Python treats strings and numbers differently. Python gets confused when you try to concatenate a string and a number, because the plus sign has a different meaning for strings than it does with numbers. Here is an example:

>>> price = 12.50
>>> print("The price is " + price)
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: Can't convert 'float' object to str implicitly
When you want the string representation of a number, you can use the repr() function to temporarily convert it to a string.

>>> print("The price is " + repr(price))
The price is 12.5 
    
Instructor Note

    
Notice that Python didn't print the trailing zero of the variable price. Later in this module we'll see how to use the % operator to take more control of the way strings are formatted for printing.

You can extract one or more characters from a string using subscripts. Subscripts are placed in square brackets after the string; a single subscript extracts a single letter. When using subscripts, remember that the first letter of a string has an index of 0, not 1.

>>>string = 'the quick brown fox'
>>> string[0]
't'
>>> string[4]
'q' 
Negative subscripts are counted from the end of the string, with -1 representing the last character.

>>>string
'the quick brown fox'
>>> string[-1]
'x'
>>> string[-5]
'n'
You can obtain the number of characters in a string by using the len() function.

>>>len(string)
19
    
Instructor Note

    
Remember that the index of the final element of a string will always be one less than the string's length, since the first character of a string has an index of 0.
 
 To extract contiguous portions of a string, you can provide two subscripts separated by a colon (:); the piece of the string that's extracted will start at the first index and continue to one character before the last index. The second index in a slice is never included in the slice.

>>> string
'the quick brown fox'
>>> string[4:9]
'quick'

For the special case of a slice starting at the beginning of a string, you can omit the first index; for a slice continuing to the end of a string, you can omit the second index:

>>> string
'the quick brown fox'
>>> string[:3]
'the'
>>> string[-3:]
'fox'

If the second index in a slice is less than or equal to the first index, the result will always be an empty string.

One of the most common uses for a string slice is to remove the newline that is present on text read from a file. Because the newline must be the last character in a line, a common practice is to replace the contents of the line with a string slice that includes everything but the last character, as illustrated in the following code:

>>> line = 'hello there\n'
>>> print(line)
hello there

>>> line = line[:-1]
>>> print(line)
hello there
>>>

Notice that a blank line appeared when printing the original version of line but not after printing the version formed from the slice.

To determine whether a particular character or string occurs in a string, you can use the in operator. If the character or string being tested is present in the string, the expression involving the in operator will return True; otherwise it will return False. For example,

>>> string = 'dead parrot'
>>> 'p' in string
True
>>> 'x' in string
False
>>> 'parrot' in string
True


Since strings are the first true objects we've encountered in our study of Python, a brief description of functions and methods is in order.

A function is simply a way to eliminate repeated code. When a function is applied to an object, it is no longer a function but is known as a method. As of Python version 2, most important operations in strings are provided as methods.

Besides the difference in terminology, methods are invoked slightly differently than functions are.

When you call a function like len, you pass the arguments in a comma-separated list surrounded by parentheses after the function name.
len(x,y)
When you invoke a method, you provide the name of the object the method is to act upon, followed by a period, finally followed by the method name and the parenthesized list of additional arguments.
object.len()
If the method does not take any arguments, remember to provide empty parentheses, as shown above, so that Python can distinguish a method call with no arguments from a reference to a variable stored within the object.

    
Instructor Note

    
If, in the subsequent commentary topics of this module I refer to methods that are not available on your system of Python, most of the same functionality is available in the string module, which I will cover in Module 8.
 
Two of the most important tasks in text processing are: 1) breaking a line of text apart into words or tokens (the split method) and 2) combining several of those pieces into a single character string (the join method).

The split method operates on a character string and returns a list whose elements are the words from that string. When no arguments are passed to the method, the default behavior of split is to split the string at every occurrence of one or more whitespace characters (space, tab, or newline). If you provide a single argument to split, each occurrence of that argument will be used to split the string.

In the example below, there's a double space after the word Ministry. Note the subtle difference between the default behavior and explicitly specifying a space as the delimiter.

>>> str = 'Ministry  of Silly Walks'
>>> str.split()
['Ministry', 'of', 'Silly', 'Walks']
>>> str.split(' ')
['Ministry', '', 'of', 'Silly', 'Walks']

Under the default behavior, the multiple spaces in the string are treated as a single separator, while explicitly specifying a blank causes an empty element to be added to the list when multiple blanks are encountered.

The split method also accepts an additional argument called maxsplit, which returns a list with at most maxsplit + 1 elements. The first maxsplit elements are what the split method would normally return, and the last element is a single character string containing the rest of the original string. Some versions of Python will not accept a named argument for this parameter; in that case, you would need to explicitly pass a separator as the first argument, using None to obtain the default behavior.

>>> str = 'Ministry of Silly Walks'
['Ministry', 'of', 'Silly', 'Walks']
>>> str.split(' ', 2)
['Ministry', 'of', 'Silly Walks']
>>> str.split(' ', 1)
['Ministry', 'of Silly Walks']
>>> str.split(' ', 0)
['Ministry of Silly Walks']
>>> str.split(None, 1)
['Ministry', 'of Silly Walks']
>>> str.split(None, 2)
['Ministry', 'of', 'Silly Walks']
>>> str.split(None, 3)
['Ministry', 'of', 'Silly', 'Walks']

The join method essentially reverses what split does by taking a list of character strings, combining the pieces while inserting a separator between each pair, and returning a single character string. The separator that is used is the value of the character string on which the method is invoked, resulting in some unusual looking statements:

verbatim
>>> words = ['spam','spam','bacon','spam']
>>> ' '.join(words)
'spam spam bacon spam' 
Of course, if you don't like the form used in the example, you can create a variable with another separator.

Notice that the list is passed as an argument to the method that operates on the separator string. The separator is not limited to a single character; any character string is acceptable.

>>> words = ['spam','spam','bacon','spam']
>>> ' and '.join(words)
'spam and spam and bacon and spam' 

Python provides two pairs of methods to locate substrings within a character string.

find and rfind, which return the location of the substring if found and -1 if the substring is not found
index and rindex, which return the location of the substring if found and raise a ValueError exception otherwise
All the methods accept optional arguments start and end, which limit the search for substrings to just the part of a string on which the method is invoked.

The methods that begin with the letter r return the highest index at which the substring was found, while the other methods return the lowest index.

Suppose we had a series of strings, each containing some parenthesized information, and we wished to extract the text found between the parentheses. After finding the index of the parentheses, we can use the slicing operators described above to extract the text we want.

>>> model = 'Turbo Accelerated Widget (MMX-42b) Press'
>>> try:
... model[model.index('(') + 1 : model.rindex(')')]
except ValueError:
... print('No parentheses found')
...
'MMX-42b' 
When you use these methods, make sure that you check appropriately for the value that indicates that the substring to search for was not found.

    
Instructor Notes

    
While these methods are useful for processing text, methods involving regular expressions, which we'll discuss in Module 8, are often more powerful. Nevertheless, these methods can often provide a simple solution to the problem of extracting text based on context.
 
Python provides a variety of methods for justifying and centering text.

The center, ljust, and rjust methods take a single argument that specifies the length of the output string within which to center, left-justify, or right-justify, respectively, the string upon which the method is being invoked.
The lstrip and rstrip methods return a string that is like the one upon which the method is invoked but without any leading (lstrip) or trailing (rstrip) whitespace; the strip method removes both leading and trailing whitespace.
Note that these methods, like all of the string methods, do not change the string upon which they are invoked. If the goal is to actually change that string, the output from the method should be reassigned to the original string object.

>>> text = 'This is a title'
>>> text.center(25)
'     This is a title     '
>>> text
'This is a title'
>>> text = text.center(25)
>>> text
'     This is a title     ' 
You can create strings with modified case by using the capitalize, lower, swapcase, title, and upper methods. For example, the capitalize method returns a string whose first character is uppercase, while all the remaining characters are lowercase. The title method capitalizes each word in the string upon which it's invoked. The other functions have their obvious meanings.

Finally, Python offers a variety of so-called predicate methods, which take no arguments and return 1 if all the characters in a string are of a particular type -- 0 otherwise.

Method
Checks for Character Type
isalnum
Alphanumeric (alphabetic or digit)
isalpha
Alphabetic
isdigit
Digit (0 through 9)
isspace
Whitespace characters (space, tab, newline, etc.)
islower
Lowercase
isupper
Uppercase
istitle
Titlecase

Python supports three types of numeric data.

floating-point numbers
integers
complex numbers
Starting with 3.0, numeric data types in Python no longer have a limit (practically speaking, but it is actually limited by your system's memory).

>>> x = 1000000
>>> x * x * x * x *x
1000000000000000000000000000000

In addition, Python automatically converts integers to floating-point numbers if necessary:

>>> 1/8
0.125

Python uses the letter j (or J) following a number to represent the imaginary part of a complex number. Alternatively, you can use the complex() function. The first argument to complex() is the real portion of the complex number, and the optional second argument is the imaginary portion. Both the real and imaginary parts of complex numbers are stored as floating-point numbers in Python.

You can convert from one type of number to another using the functions int(), float() or complex().

float() converts an integer to a float, but this is usually unnecessary. Depending on the context, Python will do this conversion automatically.
>>> x = 2
>>> float(x)
2.0

When Python encounters an integer with a leading zero and a small o, it treats the number as an octal (base 8) number instead of the more common decimal (base 10) number. Thus, Python would interpret the constant 0o12 as the number 10.

>>> value = 0o12
>>> print(value)
10

Numbers beginning with the characters 0x are treated as hexadecimal (base 16) numbers. Such numbers can contain all ten digits as well as the characters a, b, c, d, e, or f, which represent the digits with decimal values of eleven through fifteen.

Note that both octal and hexadecimal constants are numbers, not strings, and should not be surrounded by quotes. Thus, the correct way to set a variable x to the hexadecimal value 8ab would be

>>> x = 0x8ab
>>> x
2219

not

>>> x = '0x8ab'
>>> x
'0x8ab'

    
Instructor Note

    
Python always uses base 10 to print numbers, regardless of how they were entered in your programs.
 
The table below lists the numeric operators available in Python.

Operator
Purpose
+
Addition
*
Multiplication
-
Subtraction
/
Division
**
Exponentiation
These operators are known as binary operators because they take exactly two operands, one on each side of the symbol. The symbols for addition and subtraction, however, can also be used as unary operators by preceding any numeric expression.

    


    
Like most languages, Python performs multiplication and division before it performs addition, so you should be careful when constructing numeric computations. For example, Python interprets
4 + 3 * 12 - 5 * 2
as
4 + (3 * 12) - (5 * 2)
If you're not sure what order Python will use to perform your calculations, you can always include as many levels of parentheses as necessary to make your intentions clear.
 

The core language provides a few functions for numeric data, summarized in the table below; many others can be found in standard modules such as math, cmath, array, and random. (To learn more about the standard modules, you can refer to the online documentation link that was installed on your computer along with Python or to the Python Library Reference at Python.org.)

Function
Purpose
abs(x)
Absolute value
round(x)
Rounding to the nearest integer
divmod(a,b)
Integer division and modulus (%)
pow(a,b)
Alternative to **
Because there are three types of numbers in Python (floating-point, integers and complex), these functions generally return values of the same type as their input. For example, the absolute value (abs) of an integer will also be an integer.

The modulus operator (%), which we'll discuss in more detail in Commentary Topic 4.1, allows you to specify the format (exponential floating-point, or hexadecimal integer, for example) in which you want to display the value of an object.

The math module includes additional functions. Python.org also has a package of numerical routines called NumPy.

The core language provides a few functions for numeric data, summarized in the table below; many others can be found in standard modules such as math, cmath, array, and random. (To learn more about the standard modules, you can refer to the online documentation link that was installed on your computer along with Python or to the Python Library Reference at Python.org.)

Function
Purpose
abs(x)
Absolute value
round(x)
Rounding to the nearest integer
divmod(a,b)
Integer division and modulus (%)
pow(a,b)
Alternative to **
Because there are three types of numbers in Python (floating-point, integers and complex), these functions generally return values of the same type as their input. For example, the absolute value (abs) of an integer will also be an integer.

The modulus operator (%), which we'll discuss in more detail in Commentary Topic 4.1, allows you to specify the format (exponential floating-point, or hexadecimal integer, for example) in which you want to display the value of an object.

The math module includes additional functions. Python.org also has a package of numerical routines called NumPy.

Conversion of Scalar Types for String Values

While the print command will automatically convert numbers to printable strings, the numeric operators do not automatically convert strings to numeric values. You need to do the conversions explicitly.

To convert a string value to a numeric value, any of the functions int, float, or complex can be used. The following example shows the error that is raised when a value is used in the wrong context and how to correct the error. The same considerations hold when you read numeric values from a file. They will be read as strings and must be converted to the appropriate numeric type before they can be used.

>>> y = '7'
>>> x = '3'
>>> y/x
Traceback (most recent call last):
  File  "<pyshell#>", line 1, in <module>
    y/x
TypeError: unsupported operand  type(s) for /: 'str' and 'str'
>>> float(y) / float(x)
2.3333333333333335
Similarly, when you want to use a number as a string, you must explicitly call the function str. For example, suppose we wish to use the character concatenation operator (+) to append a number to the end of a filename:

>>> filename = 'myfile'
>>> i = 3
>>> newname = filename +i
Traceback (most recent call last):
  File "<pyshell#>",  line 1, in <module>
    newname = filename + i
TypeError: Can't convert  'int' object to str implicitly 
>>> newname = filename + str(i)
>>> newname
'myfile3' 

-------3

Lists provide a general way to store collections of different objects indexed by numbers. The elements that a list holds are arbitrary; they can be numeric or string values, functions, user-defined objects, or even other lists. Using lists, it is very easy to implement complex data structures.

To create a list in the Python interpreter or in a Python script, you surround the comma-separated list of the elements with square brackets ([]). Thus, a simple list of numbers can be constructed like this:

>>> numbers = [1,7,9,8,3,14] 
If your list spans multiple lines of input, you can add a newline after any of the commas and continue the list on the next line. To create an empty list -- for instance, to initialize a variable that you plan on using as a list -- use empty square brackets.

>>> newlist = [] 
The elements of a list don't need to be of the same types. For example, the following list contains numbers, strings, another list, and a function:

>>> mixlist = [1,'dog','tree',[10,12,15],-18,abs]
>>> print(mixlist)
[1, 'dog', 'tree', [10, 12, 15], -18, <built-in function abs>] 
As the above output shows, when a list contains an element that doesn't have a simple print representation (the abs function here), Python prints a description of the object inside angle brackets.

Elements of a list are extracted by providing an index number inside square brackets after the name of the list. (Remember that the first element of a list has the index 0.) The elements behave exactly as individual objects would behave. Using the list mixlist defined in the previous example, we could invoke the abs function on the fifth element of the list with the expression

>>> mixlist[5](mixlist[4])
18 
Or, we could print the first letter of the second element of mixlist as follows:

>>> mixlist[1][0]
d 

The indexing and slicing operations described for strings in Module 2 can also be used on lists, with one very important difference. 
Unlike strings, which are immutable, the contents of a list can change.
We can change the value of an indexed element or a slice of a list by putting it on the left side of the equal sign in an assignment. We can change individual elements of a list like so:

>>> x = [1,7,9,3]
>>> x[2] = ['table','chair','desk']
>>> x
[1, 7, ['table', 'chair', 'desk'], 3] 
Since we specified that the single element with index 2 was to be replaced by a list, our updated list now contains another list in that position. To add several elements to a list as separate entities, we can use a list slice on the left side of the equal sign.

>>> x[2:2] = ['table','chair','desk']
>>> x
[1, 7, 'table', 'chair', 'desk', 9, 3] 
By using the same index on each side of the colon, we let Python know that the elements of the new list should be added to the old list as individual elements, not as a list.

We can change contiguous pieces of a list with a single operation using slices.

>>> x = ['joe','fred','sally','don']
>>> x[2:3] = ['sally','harry','randy']
>>> x
['joe', 'fred', 'sally', 'harry', 'randy', 'don'] 
Notice that the list grew, because the list x[2:3] represents only one element, and we provided three in the substitution. Remember that a slice ends right before the second index of the slice.

Finally, if you need to delete an element of a list, you can use the del operator. Provide either a single index or a slice to specify the elements you wish to delete.

>>> x = [1,2,3,4,5,6,7]
>>> x
[1, 2, 3, 4, 5, 6, 7]
>>> del x[3]
>>> x
[1, 2, 3, 5, 6, 7]
>>> del x[4:]
>>> x
[1, 2, 3, 5] 
Alternatively, you can remove elements from a list by assigning an empty list to an appropriately formed list slice. For example, to remove element 2 from a list, specify a slice indexed by 2:3. Then, to remove the first three elements from the resulting list (0, 1, and 2), specify :3.

>>> x = [1,2,3,4,5,6,7]
>>> x[2:3] = []
>>> x
[1, 2, 4, 5, 6, 7]
>>> x[:3] = []
>>> x
[5, 6, 7] 

Lists in Python have other similarities to strings. In particular, the len function returns the number of elements in a list, the + operator performs concatenation, and the * operator performs repetition. (You can convert a string to a list whose elements are the characters in the string by using the list() function.)

When you use these operators on a list, both operands must be lists. Thus, we can't add an element to the end of a list by simply concatenating a scalar value; even if we wish to add a single element, it must be made into a list by surrounding it with brackets. Here is an example:

>>> x + 15
Traceback (most recent call last):
  File "<pyshell#36>",  line 1, in <module>
      x + 15
TypeError: can only concatenate list (not "int") to  list
>>> x + [15]
[1, 5, 9, 13, 15] 
The same is true for repetition. Python will interpret scalars as ordinary numbers but will create lists with all the elements of the original list repeated when the * operator is applied to a list.

>>> 5 * 0
0
>>> 5 * [0]
[0, 0, 0, 0, 0] 
As the example shows, a scalar value can temporarily be made into a list by surrounding it with square brackets.

The in operator can be used to determine if a particular value is an element of a list. It returns True if the element is found and False otherwise. Remember that the in operator looks at each element of the list but not the values within those elements.

>>>  prices = [['apple',.25],['banana',.30],['orange',.25]]
>>> 'apple' in prices
False
>>> ['apple',.25] in prices
True 
Even though the string 'apple' was contained in an element of the list, the in operator does not return True unless a complete list element is specified.

When you assign the value of one list to another, Python does not actually copy the elements of the original list to the copy; instead it "remembers" where the original list was and operates on the original list whenever you refer to the copy. A simple example will make this clear.

>>> pets = ['dog','cat','rabbit','bird','duck']
>>> animals = pets
>>> pets.append('goldfish')
>>> animals
['dog', 'cat', 'rabbit', 'bird', 'duck', 'goldfish'] 
Notice that when we appended the value of 'goldfish' to the pets list, it also got appended to the animals list.

If you really want to make a copy of a list, you can do it essentially by using a slice of the list that includes all its elements: specify a subscript of simply a colon (:). Because no starting or ending subscript is supplied in this case, Python defaults to using the entire list, and a true copy will be made. Notice the difference in the animals list when we copy the pets list to it in this way:

>>> pets = ['dog','cat','rabbit','bird','duck']
>>> animals = pets[:]
>>> pets.append('goldfish')
>>> animals
['dog', 'cat', 'rabbit', 'bird', 'duck'] 
Now, changes in the pets list have no effect on the animals list, since a true copy was made. The copy module provides this same functionality as well as the ability to make true copies of more complex data structures.

We'll look at the append function applied as a method in a moment. First, let's stop to take a look at object orientation and methods as they are used on lists.

Many useful actions on lists are performed by methods instead of functions. Methods are part of a programming philosophy called Object-Oriented Programming (OOP). While OOP is built into Python by design, remember that you can productively use Python as an ordinary programming language and only incorporate the concepts of OOP when you need them.

Here's a brief overview of OOP:

The basis of OOP is that, as a programmer, you should focus on the data you are working with, whether it is the results of a scientific experiment, counts of hits on a Web page, or the contents of your personal CD collection.
Instead of keeping track of this data in separate locations, it is incorporated into an object, which contains all the information you would need to know to operate on the data.
Methods are then constructed that know how to operate on those objects. Since the object contains all the available information, it's not necessary to assemble any additional information to invoke the method.
Furthermore, when you invoke a method on an object, Python figures out which method to run, because it recognizes the object as having special properties. So, for example, if you had a CD collection and a tape collection, you could create a print method for each, and when you want to print the contents of a tape or CD, simply invoke it by name -- Python will figure out which method to use for which object.

Invoking a method on an object is similar to invoking a function, but instead of including the object in the argument list as with a regular function, you precede the method call with the name of the object followed by a period. Thus, to invoke the print method for our fictitious CD collection on a CD object called album1, we would type

album1.print() 
instead of

print(album1) 
Additional arguments to methods, if present, would be passed to the method just as they would be for functions.

While you can use slicing and concatenation to manipulate lists, list methods provide alternatives that can be more convenient and powerful. The methods in the table below modify the object on which they are invoked.

Method
Use
append
Adds a single element to the end of a list
extend
Adds several elements to the end of a list
insert
Inserts a single element anywhere in a list
remove
Removes the first occurrence of a value from a list
reverse
Reverses the order of a list in place
append and extend

It is important to notice the difference between append and extend. A simple example involving two lists should make this difference clear:

>>> office = ['desk','chair','file cabinet']
>>> lounge = ['sofa','table']
>>> office.append(lounge)
>>> office
['desk', 'chair', 'file cabinet', ['sofa', 'table']]
>>> office = ['desk','chair','file cabinet']
>>> office.extend(lounge)
>>> office
['desk', 'chair', 'file cabinet', 'sofa', 'table'] 
While append and extend each take exactly one argument, the argument passed to append is added to the list as a single element; the length of the list increases by exactly one.

When using extend, however, each element of the argument passed to the method is added to the list as a separate element; the length of the list increases by the length of the argument to the extend method.

Notice that, since the method modifies the list it's acting upon, the variable office had to be reinitialized to show the difference in the two methods when acting on identical lists.

insert

The insert method can insert exactly one element into a list. To insert more than one element in a single operation, you must assign the elements to a list slice. Thus, to add the element 'cat' to the array animals after the element 'dog', we could use the following:

>>> animals = ['duck','chicken','dog','horse','frog']
>>> animals.insert(3,'cat')
>>> animals
['duck', 'chicken', 'dog', 'cat', 'horse', 'frog'] 
The same 
  result could be achieved using an assignment to a list slice.

>>> animals = ['duck','chicken','dog','horse','frog']
>>> animals[3:3] = ['cat']
>>> animals
['duck', 'chicken', 'dog', 'cat', 'horse', 'frog'] 
remove

The del operator introduced in Topic 3.2 allows us to delete a list element by specifying it with an index, but the remove method removes the first instance of an element in a list that has a given value. Since it is an error to try and remove an element that is not present in a list, it is often a good idea to check for it first.

>>> nums = [1,2,7,3,9,7,2,8,7,3]
>>> x = 4
>>> if x in nums:
... nums.remove(x) 
To remove all elements with a particular value from a list, the remove method can be invoked repeatedly in a while loop, until the value is no longer in the list.

>>> nums
[1, 2, 7, 3, 9, 7, 2, 8, 7, 3]
>>> while 3 in nums:
... nums.remove(3)
...
>>> nums
[1, 2, 7, 9, 7, 2, 8, 7] 
We will discuss if and while loops more fully in Module 5.

reverse

The reverse method simply reorders the elements of a list so they are the opposite of their original order.

>>> x
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> x.reverse()
>>> x
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 
Notice that reverse does not return the reversed list; it changes the object in place. If you need both the original list and the reversed list, you'll need to copy the list before reversing it.

While sort modifies the object on which it is invoked, count and index return results about the list itself.

Method
Use
sort
Sorts elements of a list in place
count
Counts the number of times a value appears in a list
index
Returns the index of the first occurrence of a value in a list
sort

Python provides two methods that reorder the elements of a list. I'll address the advanced method shortly.

>>> food = ['eggs','bacon','spam','sausage']
>>> food.sort()
>>> food
['bacon',  'eggs', 'sausage', 'spam']
>>> nums = [14,19,22,31,16] 
>>> nums.sort()
>>> nums
[14, 16, 19, 22, 31] 
Advanced Sorting

You can pass a function to the sort method to tell Python how to order the objects that you need sorted. You should model this function on the built-in function cmp, which returns

-1 if its first argument is greater than the second
0 if the two arguments are equal
+1 if the second argument is greater than the first
We'll look at function definitions in more detail later, but for now let's say we want to sort strings, while ignoring the case of the strings. We can use the lower function in the string module to return the lowercase version of a string, and if we use that version to compare pairs of values, the strings will be sorted without regard to case. We can write a function to do this comparison as follows:

>>> def nocase(a):
... return a.lower()
...
>>> names = ['fred','judy','Chris','Sam','alex','Heather']
>> copynames = names[:]
>>> names.sort()
>>> names
['Chris', 'Heather', 'Sam', 'alex', 'fred', 'judy']
>>> names = copynames[:]
>>> names.sort(key=nocase)
>>> names
['alex', 'Chris', 'fred', 'Heather', 'judy', 'Sam']
count

While the in operator can tell whether a particular element is contained in a list, the count method can tell how many times an element appears in a list. For example:

>>> food = ['spam','spam','spam','sausage','spam']
>>> food.count('spam')
4 
index

The index method gives the position of the first occurrence of a value in a list.

>>> food = ['spam','spam','spam','sausage','spam']
>>> food.index('spam')
0
Because count and index are methods, they are invoked by placing the name of the object they are invoked on before the method name, separated by a period.

Tuples are similar to lists, but, like strings, tuples are immutable -- the contents of a tuple cannot be changed. (As a side note, that restriction allows Python to work with tuples a bit more efficiently than it works with lists.)

Tuples are required in certain functions and for certain operations, so you need to know how to construct and manipulate them.

Tuples are necessary to provide data for formatting processes that use the % operator. (We'll examine this use more closely in Commentary Topic 4.1, when we discuss printing.)
Tuples can be used as keys in dictionaries, which we'll discuss in the next commentary topic.
Lists cannot be used in either of those situations.

Tuples are created just like lists, except that, instead of using square brackets, you use parentheses to surround the comma-separated elements. An empty tuple is represented by an empty set of parentheses (()). The use of parentheses creates a syntactic dilemma for the Python interpreter in the case of a tuple with only one element, since the parentheses may simply be used as grouping in a complex expression. So, for a tuple with only one element, you must follow that single element with a comma (unlike a list where a single element list can be expressed by just surrounding the element with square brackets).

Create a tuple with code like the following:

>>> tupl = (3,7,12,13,19)
Now, suppose that you want to append the value 21 to the end of the tuple. Because tuples are immutable, there is no append method as there is for lists; you need to concatenate the new value at the end of the original tuple and reassign its value back to that tuple.

>>> tupl = tupl + (21,)
>>>  tupl
(3, 7, 12, 13, 19, 21)
Alternatively, you could convert the tuple to a list (with the list function), append the value, and convert the list back to a tuple:

>>> tupl = (3,7,12,13,19)
>>> ltupl = list(tupl)
>>> ltupl.append(21)
>>> tupl = tuple(ltupl)
>>> tupl
(3, 7, 12, 13, 19, 21) 
You can use similar techniques to sort a tuple or reverse the order of its elements.

Like lists, dictionaries can contain a collection of arbitrary objects, but instead of being indexed by consecutive integers, they can be indexed by any immutable object, such as a string or a tuple.

Because strings are usually more convenient to remember than numbers, dictionaries provide a useful way to store information. Consider a phonebook. While we could create a list with pairs of names and numbers then search through each pair for a name whose number we wanted, dictionaries make the job much easier. Once the dictionary is created, you simply provide the name you want as an index, and the appropriate number is returned. Each element of a dictionary consists of two parts.

the key, which is the object used to index a value
the value itself
When you create a dictionary, separate key/value pairs with a colon (:) and surround a comma-separated list of such pairs with curly braces ({}). So a phonebook could be created with statements like the following:

>>> phonebook = { 'Fred':'555-1231','Andy':'555-1195','Sue':'555-2193' }
To access a particular value, simply use its key as the index to the dictionary.

>>> phonebook['Sue']
'555-2193' 
Additional elements can be added to a dictionary through an assignment statement.

>>> phonebook['Harry'] = '555-3915' 
To index a dictionary using multiple values, a tuple can be used.

>>> tupledict = { (7,3):21,(13,4):52,(18,5):90 }
Any expression that evaluates to an equivalent tuple can be used as a key.

>>> tupledict[(4+3,9/3)]
21 

len Function

As it does for lists, strings, and tuples, the len function returns the number of values stored in a dictionary (that is, the number of key/value pairs the dictionary contains).

Checking for nonexistent keys

If you try referring to a nonexistent key, Python generates a KeyError exception. The in operator returns True if the specified dictionary contains the key passed as its argument and False otherwise. It can be used in an if clause to avoid using a nonexistent key.

>>>  number = None
>>> name = 'Sue'
>>> if name in phonebook:
...number = phonebook[name]
... 
get Method

The get method also accepts a key as an argument and will return the element of the specified dictionary if it exists. But if the dictionary does not contain that key, it will return the method's optional second argument, which defaults to None. So the previous example could be written as

>>> name = 'Sue'
>>> number = phonebook.get(name) 
Using Exceptions to prevent KeyErrors

As an alternative to the methods described above, we can use Python's try/except clause to handle possible KeyErrors that arise from trying to access a dictionary using a nonexistent key. For the phonebook example, we could use the following code to set the value of number to None in the case where the specified key didn't exist.

>>> name = 'Sue'
>>> try:
... number = phonebook[name]
... except KeyError:
... number = None
... 
It is a matter of personal choice which method to use to make sure that a key exists before trying to access a dictionary.

Other Methods for Dictionaries

Starting with Python 3.0, dictionary methods such as keys(), values() and items() return a view object. They are preferable to lists in that they are dynamic. In other words, changes to the dictionary will be reflected in a view object.

The keys method returns a view object of just the keys of a dictionary without the corresponding values.
The values method returns a view object just the values of a dictionary, without the keys, but in an order corresponding to the order that the keys method returns the keys.
Finally, the items method returns a view object, each element of which is a key/value pair stored in a tuple. The ordering of these tuples once again corresponds to the ordering returned by the keys method.
Calling the above methods directly will return the view object and not its contents. To see its contents in list format, use the list() function, which will convert it to a list.
Here's the result of applying each of these three methods to the phonebook dictionary:

>>> phonebook.keys()
<dict_keys object at 0x01334050>

>>> list(phonebook.keys())
['Sue', 'Andy', 'Fred']
>>> phonebook['Harry'] = '555-3915'
>>> list(phonebook.keys())
['Sue', 'Andy', 'Fred', 'Harry']
>>> list(phonebook.values())
['555-2193', '555-3915', '555-1195', '555-1231']
>>> list(phonebook.items())
[('Sue', '555-2193'), ('Harry', '555-3915'), ('Andy', '555-1195'), ('Fred',  '555-1231')]
In addition, you can iterate through the elements of a dictionary with in and a loop:

>>> for name in phonebook.keys():
...   print(name)

Sue
Harry
Andy
Fred

------ 4

We've seen that when you use the Python interpreter, simply typing the name of an object will provide a printed representation of it. But when you're writing a script, you need to use the print statement explicitly. On its own, however, the print statement doesn't provide much control over the appearance of the output, especially for numbers. For example, suppose you are calculating the tax on a purchase and are using a tax rate of 7.25 percent (.0725). If you allow Python to decide on the number of decimal places to print, it has no way of knowing that you're calculating a price in dollars and cents, so it may print more decimals than you need.

>>> price = 21.95
>>> tax = price * .0725
>>> print(tax)
1.591375 
The modulus operator (%) allows you to specify the format in which you want to display the value of an object. The modulus operator is not a part of the print statement; it is simply a way to create a string with more control over the way objects are formatted.

The operand on the right side of the % can be a single value, or it can be a tuple or dictionary that contains the values to be printed.

On the left side of the %, you'll put a string containing formatting codes, which I've summarized in the following table:

Code
Meaning
d or i
Decimal integer
u
Unsigned integer
o
Octal integer
h or H
Hexadecimal integer
f
Floating-point number
e or E
Floating-point number, exponential form
g or G
Floating-point number, "optional" representation
s
String value -- also provides default representation for any object
c
Single character
%
Literal percent sign
For these codes to work, you'll need to precede them with a percent sign and, optionally, a number. (Yes, the percent sign plays two roles in the formatting process -- as the binary operator and also as an indicator that a formatting code is following.)

When a number is used along with a formatting code, it indicates the width of the field in which the formatted value will be placed. If no number is given, the default representation, similar to what's displayed in an interactive session, will be placed in the output string.

For floating-point numbers, we can specify both a field width and a number of decimals, separated by a period. So to create a string representation of the tax value in the previous example, we could use the following statements:

>>> price = 21.95
>>> tax = price * .0725
>>> ftax = '%4.2f' % tax
>>> print(ftax)
1.59 
Since, in this example, we're only concerned with the number of decimals, we could omit the field width (but not the separating period), like this:

>>> '%.2f' % tax
'1.59' 
Formatting Multiple Values

When you're formatting a single value, there's no confusion about which variable is being used with what format. But when you're formatting a more complex example, it is very helpful to be able to specify the name of the variable that is being formatted at the same point as the formatting code itself. When the right-hand operand is a dictionary, you can provide the keys of the objects to be printed between the percent sign and the remainder of the formatting code in the left-hand operand string. Here are two equivalent ways to format several values in a single string:

>>> quantity = 3
>>> itemprice = 1.95
>>> totalprice = 3 * 1.95
>>> '%d items at %.2f for a total of %.2f' % (quantity,itemprice,totalprice)
'3 items at 1.95 for a total of 5.85'
>>>
>>> vals = {'quantity':3,'itemprice':1.95,'totalprice':3*1.95 }
>>> '%(quantity)d items at %(itemprice).2f for a total of %(totalprice).2f' % vals
'3 items at 1.95 for a total of 5.85' 
Since the built-in function locals returns a dictionary whose keys are the names of all the currently defined variables and whose values are the values of those variables, it's usually not necessary to explicitly form a dictionary as we did in the previous example.

>>> name = 'joe'
>>> food = 'spam'
>>> 'my name is %(name)s and my favorite food is %(food)s' % locals()
'my name is joe and my favorite food is spam' 
    
Instructor Note

    
By default, the print statement terminates its output with a newline. To suppress this behavior, use a comma as the very last character of the print statement.
 
While much of your work may be accomplished by displaying information on a computer screen, it's often necessary to read and write information to and from files. In Python, reading and writing is done through a file object.

The built-in open function is used to create a file object. This function takes between one and three arguments.

The first argument is the name of the file.
The second argument is a string describing the action(s) you wish to perform with the file. The possible values for the second argument are listed in the table below.
 

Argument
Meaning
'r'
Open file for reading; the file must exist
'w'
Open file for writing; the file will be created if it doesn't exist
'a'
Open file for appending; the file will be created if it doesn't exist
'r+'
Open file for reading and writing; if the file exists, its content is not destroyed
'w+'
Open file for reading and writing; if the file exists, its content is overwritten
'a+'
Similar to 'r+'
If no second argument is supplied, the file will be opened for reading as if the string 'r' was supplied.

Finally, a third argument, which is usually not necessary, tells Python how to perform buffering for the file.
A value of 0 means no buffering. (Anything written to the file will immediately appear in the file.)
A value of 1 means line buffering. (Information is written to the file only when a newline character is sent to it.)
Any other non-zero value is the size of the buffer that will be used when transferring information to the file.
Python will issue an IOError exception if it encounters any problems when opening a file, so it's a good idea to open files within a try/except clause to make sure your program won't terminate.

Once you've created a file object for reading, three methods can be used to read its contents.

Method
Use
readline
reads one line from a file
readlines
reads entire file; returns list of elements
read
reads entire file; returns scalar string
readline

The readline method will read one line from the specified file. Repeated calls to the readline method will continue to read one line at a time, until the entire contents of the file have been read. Since the line returned by the readline method will always be terminated by a newline, it's a common practice to use a string slice to eliminate the newline.

Suppose we have a file called inputfile, which consists of the following:

line one
line two
line three 
We could read the first line of this file using the following code:

>>> f = open('inputfile','r')
>>> line = f.readline()
>>> line
'line one\n'
>>> line = line[:-1]
>>> line
'line one' 
Subsequent calls to readline would continue to read the remaining lines, until an empty string is returned, signaling there are no more lines in the file to be read. Thus, you can use a call to readline inside a while loop to process files of arbitrary length, reading only one line at a time.

readlines

The readlines method reads an entire file in a single call and returns a list of elements, each of which represents a single line from the file. Once a call to readlines is made, subsequent calls will return an empty list, unless the file is rewound, or closed and then reopened.

read

Finally, the read method will read the entire contents of a file, returning a scalar string with embedded newlines. An optional integer argument to the read method will limit the number of bytes that are read. When this argument is supplied, subsequent calls to read will continue where the previous call left off.

In addition to printing the values of the data we manipulate in Python, it's often necessary to store information in a file so you can access it later or so another program can use it. Let's look at several ways of writing to a file.

write

To write to a file, a file object must be created with a second argument of 'w', 'a', 'r+', or 'a+'. Then the write method will take its single scalar argument and write it to the file represented by the file object.

Unlike the print statement, the write method does not append a newline to its output, and that allows the write method to be used with all types of files, not just text files. If you want a newline to be written to the file, you must explicitly put it in the argument to the write method.

writelines

The writelines method accepts a single list as an argument and writes each element of the list as if a call were made to the write method with that element. As with the write method, newlines are not automatically added to the output.

print

Starting with Python 2.0, it's possible to use an extended form of the print statement to write to a file. Because the print statement automatically adds a newline at the end of each line you print, in some circumstances you may find it more convenient than the writing methods. In addition, if you want to modify an existing program so that it prints to a file instead of the screen, it will be easier to simply change the print statements in your program rather than convert them to calls to the write method.

To use this extended form of the print statement, open the file you'll be writing to, making sure that you specify a mode of 'w' in the call to open. Then include the file object's name in as the second argument in the print statement. Also, precede it with 'file='.  By default, the file argument in print is set to stdout (the screen). 
For example, the following statement prints the text "Hello, world" to the screen, automatically inserting a newline at the end of the printed line:

>>> print('Hello, world')
Hello, world 
To write the same text (including the automatically generated newline) to a file called hello.out, we could use the following statements:

>>> try:
... hello = open('hello.out','w')
... except IOError:
... print("Couldn't open hello.out for writing")
...
>>> print('Hello, world', file=hello)
>>> hello.close() 
Notice that the file must still be opened before writing, and it must be closed when you're done writing to it.

While opening, reading, and writing are the three most important operations when it comes to files, the methods below give you more control over the files that you work with.

close

You can use the close method, which accepts no arguments, to close a file after you are done reading from or writing to it. Since Python will automatically close open files when you try to re-open them or when your program terminates, it's not always necessary to explicitly close your files. If you are opening a number of file objects within a program, however, it's generally a good idea to close them when you're done with them.

flush

With buffered input or output, the flush method is useful because it ensures that a file's buffers are emptied. If the argument you pass to the write function doesn't seem to be turning up in the file to which you are writing, invoking the flush method on the appropriate file object will usually solve the problem.

tell and seek

Because the reading and writing methods automatically keep track of where you are in a file, it is common to use the methods, repeatedly if necessary, until all the desired data is either read from or written to the file you're working with. For some large files, however, you may want to jump ahead to a particular location before reading or writing. Python provides two methods to make this sort of task possible: tell and seek.

The tell method returns the current offset of a file object in bytes -- in other words, the location in the file where the next operation (read or write) will take place.

To set that value, the seek method can be used. This method takes two arguments.

The first is the desired offset in bytes.
The second (optional) argument tells Python whether the offset is from the beginning of the file (0, the default), the current position (1), or the end of the file (2). For example,
     object.seek(15,0)
After a call to seek, subsequent reads or writes will start at the location in the file that you specified in the call to seek. Although there is no explicit "rewind" method for files, a file can be rewound by calling seek with an argument of 0. After such a call, the next read or write to the file will be performed at the beginning of the file, making such a call useful if you need to read a file twice within the same program. (Alternatively, the file could be closed and then reopened.)

truncate

Finally, the truncate method takes a single integer argument and changes the length of the file represented by the file object to the specified argument in bytes. If the argument is greater than the current length of the file, the file is padded with zeros (not blanks).

In addition to the methods described previously, a file object also contains variables (often referred to as attributes) that provide information about the file. You can access these attributes just like methods, but because they are variables, they take no arguments and thus do not require parentheses after their names.

The name attribute is either the name of the file from which the file object was created or a string describing the object's source if it wasn't a file.
The closed attribute is an integer variable that is 1 if the file is closed and 0 if the file is open.
The mode attribute is a variable containing the mode with which a file object was originally opened.
All these attributes are read-only and will generate a TypeError if an attempt is made to change them.

In addition to normal files, there are three so-called streams that are available for use within Python. These streams are known as

standard input (usually the keyboard)
standard output (usually the computer screen)
standard error (also usually the computer screen, but a separate stream from the standard output)
Although they are not files in the usual sense of the word, they behave like files in terms of reading and writing.

The sys module provides file objects for these three streams, with the objects having the names stdin, stdout, and stderr, respectively. So to create a simple interactive program, it can suffice to read input from stdin and write output to stdout.

    
Instructor Note

    
Because some operating systems allow standard output to be redirected to a file, it's a good idea to write error messages to stderr instead of stdout.
 
        
The following program imports stdin and stdout from the sys module and then establishes a trivial dialogue with the user:

from sys import stdin, stdout
len = stdout.write("What's your favorite color? ")
answer = stdin.readline()[:-1]
stdout.write('I like %s too' % answer) 
The first call to write is not terminated in a newline, so the cursor will remain on the current line waiting for the user's response. The call to readline is immediately sliced to remove the trailing newline that readline always includes. Finally, a newline () is explicitly added to the final call to stdout.write, so the cursor will be in the proper location after the program is finished. (Note: len contains the length of the string passed to stdout.write.)

As an alternative to reading input from a file, it's sometimes more convenient to read input from a program that is executed by the operating system. Similarly, sometimes it's useful to write a program whose output is read by some other program. Situations like this are handled by what are known as pipes.

A pipe behaves just like a file, but it represents either the standard output from some program or the standard input to some program. In Python, you can create a pipe object with the popen function from the os module. To use this function, you can perform one of the two following actions:

import just the popen function using the statement from os import popen
import the entire contents of the os module with the statement import os
In the first case, you would simply refer to popen when you needed to create a pipe; in the second case, you'd need to refer to os.popen, since only the module itself was imported into your program.

Pipes give us another opportunity to see the benefits of Python's object-oriented design. Once you create a pipe object in Python, you can use identical methods to those already described for files. The only difference is the single call to create the object: you create file objects by passing a filename to the built-in function open, while you create pipe objects by passing an operating system command to the popen function of the os module.

(We'll see later that there are other, similar types of objects available. For example, the urlopen function from the urllib module lets us read from any object on the Internet just as if it was a local file.) 
A common use of pipes is to take the output of an operating system command and display the information from the command in a more simplified format. If you are using replace dir with ls.

import os
du = os.popen('du /usr/local') 
while 1: 
      line = du.readline() 
      if not line: 
            break 
      if list(line).count('/') == 3:    
            print(line)  
If we run the du command on the directory /usr/local, we might see output like this:

1       /usr/local/etc/httpd 
35      /usr/local/etc/xlogmaster/sound 
7       /usr/local/etc/xlogmaster/scripts 
51      /usr/local/etc/xlogmaster 
4       /usr/local/etc/sound/events 
5       /usr/local/etc/sound 
23      /usr/local/etc/CORBA/servers 
24      /usr/local/etc/CORBA 
24      /usr/local/etc/gtk
23      /usr/local/etc/sane.d     
(and so on)

However, the script above filters the output to a more manageable form.

235     /usr/local/etc 
1       /usr/local/games 
288359  /usr/local/lib 
3619    /usr/local/info 
10740   /usr/local/man 
7814    /usr/local/sbin 
1       /usr/local/src 
4667    /usr/local/include 
838     /usr/local/doc 
1133    /usr/local/libexec  
(and so on)

---- 5

Perhaps the most basic operation in any computer language is the assignment statement, which allows us to associate a particular value with a named variable. Like many other languages, Python uses the equal sign (=) to assign a value to a variable. The variable name is put on the left side of the equal sign, and the value we wish to assign to the variable is put on the right side. Some simple examples of assignment statements are shown below.

>>> x = 3
>>> y = 'This is a string'
>>> z = x + 3
>>> y = abs(-7)
>>> vegies = ['broccoli','peas','carrots']
>>> meal = vegies 
Assignment statements can be chained, which allows you to assign the same value to several variables in a single statement.

>>> count = number = check = 0 
All three variables (count, number, and check) will have the value of 0 after the assignment. When you use an assignment statement, notice that Python does not echo the value of the assignment to the screen as it would if a Python expression without an assignment were typed into the interpreter.

Multiple Assignments

An assignment statement also supports multiple assignments of different values in a single statement by using comma-separated collections of expressions on the two sides of the equal sign.

>>> five,ten,twenty = 5,10,20
>>> all = first,last = ['Fred','Jones'] 
The second example shows that a list (or tuple) can appear on the right side of the assignment statement, and its contents can be separated into individual variables. The list all has two elements ('Fred' and 'Jones'), and the scalar first is equal to 'Fred', while the scalar last is equal to 'Jones'.

'Remembering' the Assigned Variable

While the internal details of Python are usually irrelevant when you use the language appropriately, there is one aspect of the assignment statement that you need to be aware of. When you assign one variable to another variable, Python doesn't actually copy the original variable to its target; instead, it "remembers" where the original variable was and uses that original variable when you refer to the copy. By storing references to objects instead of copies of the objects themselves, Python can operate much more efficiently.

If an entirely new object is assigned to the original variable, Python will actually copy the old contents of the variable to any other variable that is referring to it. But if the original copy is a mutable object and only some elements of it are changed, then Python will not change any copies of the object. A simple example should illustrate these points.

>>> x = 7
>>> y = x
>>> y
7
>>> x = 9
>>> y
7
>>> pets = ['dog','cat','bird','goldfish']
>>> animals = pets
>>> pets[1] = 'hamster'
>>> animals
['dog', 'hamster', 'bird', 'goldfish'] 
In the first example, with x and y, it really doesn't matter that y is only a reference to x because, as soon as a scalar value is changed, Python will actually make the necessary copy. But in the second example, the change made to one of the elements of the pets list is reflected in the value of animals, because lists are mutable and only part of the list has changed.

Notice if we completely replace the value of pets, a copy of the current value of the pets list will be copied to animals.

>>> pets = ['horse','duck','snake','mouse']
>>> animals
['dog', 'hamster', 'bird', 'goldfish'] 
Making a Real Copy

When you do need to make an actual copy of a mutable object (for example, if you need to keep original and revised versions of a list of values), there are two ways to ensure that a real copy is made.

The first was introduced in Topic 3.2, namely, taking a slice consisting of the entire contents of the array. In the pets and animals examples, notice how assigning a slice removes the dependency of the animals list on the pets list.

>>> pets = ['dog','cat','bird','goldfish']
>>> animals = pets[:]
>>> pets[1] = 'hamster'
>>>  animals
['dog', 'cat', 'bird', 'goldfish'] 
The other possibility is to use the copy function from the copy module.

>>> import copy
>>> pets = ['dog','cat','bird','goldfish']
>>> animals = copy.copy(pets)
>>> pets[1] = 'hamster'
>>> animals
['dog', 'cat', 'bird', 'goldfish'] 
    
Instructor Notes

    
If you have complex data structures, such as lists nested within lists, use the deepcopy function of the copy module. The regular copy function does not descend embedded lists and actually copy them. Instead, it stores references to those embedded lists in the copy it produces.
 
        
Unlike most programming languages, in which indentation is used only to make programs more readable, indentation is an integral part of all the programming constructs in Python. Rather than use braces or keywords, Python signals the beginning of a block of statements by indentation. It signals the end of a block of statements by a return to the previous level of indentation. The first statement of your Python program, whether typed interactively or stored in a file, must begin in the very first column.

Although it takes some getting used to, using indentation to group statements has some very attractive benefits. Since there are no brackets or keywords, most Python programs, regardless of who has written them, tend to look pretty similar, making it very easy to read and understand other people's (or even your own) programs. And, unlike many languages in which indentation can give false cues about the organization of a program, in Python, the structure of a program is almost guaranteed to be reflected in the way the program looks.

The Indentation Rule

The rule for indentation is very simple.

There is no fixed amount by which lines need to be indented; you simply need to be consistent within each block.
Even so, most Python programmers tend to indent each block by the same number of spaces. Editors such as emacs, vim, and the IDLE programming environment, which is shipped with Python, are aware of Python's syntax and make it easy to maintain consistent indentation.

Occasionally, if you create a file with one editor and then process it later with a different editor, Python will get confused about indentation. The consensus of Python experts who have examined these cases is that the problem has to do with some editors using tabs and others using spaces. More specifically, problems like this have been traced to indentation that consists of a mixture of tabs and spaces, a practice that you should definitely avoid.

Python provides several programming constructs that allow you to execute statements based on some condition. Before examining those constructs, we should take a moment to understand what Python's ideas of true and false are.

In Python, numeric values are false if they are equal to 0 and true otherwise.
Sequence objects (strings, lists, and tuples) are false if they contain no elements and true otherwise.
Similarly, dictionaries are false if they have no key/value pairs and true otherwise.
Finally, the special Python value None is always false.
More commonly, however, you'll use binary comparison operators to create logical expressions. The result of the comparison will be 0 if the test is false and 1 if the test is true. The available comparison operators are summarized in the table below.

Operator
Tests for
==
Equality
>
Greater than
>=
Greater than or equal
in
Membership in sequence
not in
Lack of membership
!=
Non-equality
<
Less than
<=
Less than or equal
is
Equivalence
not is
Non-equivalence
Two of these operators -- in and is -- deserve special mention.

The in Operator

The in operator allows you to determine whether an element is a member of a sequence -- for example, if a particular letter is found in a string, or if a particular object is an element of a list or tuple.

Suppose we have a list of names, and we wish to construct a new list containing only the unique names we encounter in the original list. In other words, we want to add a name from the original list to our new list only if it is not already present in the new list. In many programming languages, this problem is solved by examining a new name and using a loop to check all the values already in the list to make sure that the new name is not there before adding it. In Python, the in operator eliminates the need for the loop and, as an extra bonus, searches the existing values in the list faster than a simple loop would. Thus, the problem of building a list of unique names could be solved with code like the following:

>>> orig = ['Fred','Sue','Tom','Fred','Sue','Billy','Harry','Sue'] 
>>> new = [] 
>>> for name in orig: 
...     if name not in new: 
...             new.append(name) 
... 
>>> new 
['Fred', 'Sue', 'Tom', 'Billy', 'Harry']            
The is Operator

The is operator takes advantage of the way Python assigns one object to another; if two objects are a reference to the same object, then comparing them with the is operator will test true. Here's an example:

>>> nums = [1,2,4,5,9]
>>> x1 = nums
>>> x2 = nums[:]
>>> x1 is nums
1
>>> x2 is nums
0 
Almost all the comparisons you'll use to see if two objects are equal will use the equality test operator (==) and not the is operator. The main use of the is operator is to verify whether a variable is a copy of another variable or is simply a reference to it (in those cases where you need to retain an unmodified version of a mutable object that you are about to change). To extend the previous example, if we changed a value in the nums list, the corresponding value in x1 would change, but the value in x2 would not, as illustrated below.

>>> nums[3] = 500
>>> nums
[1, 2, 4, 500, 9]
>>> x1
[1, 2, 4, 500, 9]
>>> x2
[1, 2, 4, 5, 9] 
Compound 
  Logical Expressions


Logical expressions 
  can be combined using the operators and and or. 

For two expressions joined by an and to be true, both of the expressions must be true.
For two expressions joined by an or to be true, at least one of them must be true.
Python, like most modern programming languages, will only evaluate expressions in a compound logical expression until it can determine whether the overall, joined expression is true. Also, expressions are always evaluated from left to right. These two factors have consequences in our coding.

Consider the following example. Suppose we wish to count the number of words in a character string and print a message if there are more than three words, but only if the length of the character string is greater than five. In the code that follows, the split function of the string module is called -- but without properly importing the module. Due to the way that logical expressions are evaluated, the error may not be immediately apparent.

>>> mystr =  'one'
>>> if len(mystr) > 5 and len(split(mystr)) > 3:
... print('Too many words')
...
When the string being tested, mystr, is less than five characters, the first test, len(mystr) > 5, is false, and because the expression being tested is formed using an and, Python knows that the overall expression cannot be true and doesn't evaluate the second expression, len(split(mystr)) > 3. Thus, the error is not detected. But as soon as the code is used with a longer string, as shown below, the error becomes apparent.

>>> mystr =  'one two three' 
>>> if len(mystr) > 5 and len(split(mystr)) > 3: 
... print('Too many words')
... 
Traceback (most recent call last):
  File "<pyshell#138>", line 1, in <module>
    if len(mystr) > 5 and len(split(mystr)) > 3:
NameError: name 'split' is not defined
    
Instructor Note

    
When constructing logical expressions, remember that Python may not necessarily evaluate all the parts of the expression, and make sure to test your programs using values that will ensure that all parts of the expression will be evaluated.
 
Although useful programs can be written by just combining single statements that are each executed only once, most programs require additional control over the execution of statements.

Conditional Execution

The first type of control is known as conditional execution. Instead of every statement in your program being executed, conditional execution gives you the ability to execute groups of statements only if some logical condition is found to be true.

In Python, conditional execution is achieved using the if statement, which also provides elif and else clauses so that you can specify alternative statements to be executed if the condition being tested is not true.

Looping

The other type of control is looping, or the ability to execute certain statements over and over again. There are two looping structures.

the for loop, which allows you to operate on each element of a sequence (such as a list, tuple, or string)
the while loop, which allows you to repeatedly execute statements as long as some logical condition is true
In addition, Python provides the tools to override the default behavior of loops when necessary. Like many other aspects of Python's design, the limited number of control statements in Python does not hurt its functionality but rather makes it easier to choose the right technique for the programming task at hand.

The if statement, along with optional elif and else statements, is the basic tool for conditional execution in Python. The statements are structured as follows:

      if expression: 
         statement(s) 
      elif expression: 
         statement(s) 
           . . . 
      else: 
         statements 
You can use an unlimited number of elif statements but only one else statement.

You must put colons (:) at the end of every if, elif, and else statement, and you must appropriately indent the statements that are to be executed when the various expressions are true.

Order of Execution

Python first evaluates the expression after the initial if. If it is true, the indented statements following that line are executed, and the remaining elif and else statements (if present) are skipped.

If the initial expression is not true, Python evaluates the expressions following subsequent elif statements (if present). If it finds a true expression, it executes the indented statements following it and skips over the remaining elifs and else.

Finally, if there is an else statement present, and none of the preceding expressions are true, the indented statements following the else statement are executed.

    
Instructor Note

    
There is one point I want to make regarding the use of elif statements. As I explained above, expressions in a chain of if and elif statements are evaluated only until a true expression is found, and the remaining expressions are simply skipped. So, when testing for a set of conditions of which only one can be true, it is more efficient to use a single construction of if and elif statements than to use separate if statements for each possibility. When you use separate if statements, each of the expressions being tested has to be evaluated.
 
        
The for loop lets you iterate over the elements of a sequence (string, list, or tuple), performing the same task on each of the elements. The basic form of the for loop is

  for var in sequence: 
      statements 
  else: 
      statements 
As with the if statement, there must be a colon (:) at the very end of the for statement, and, as always, the statements following both the for and the optional else must be properly indented.

In the example above, the first time the loop is executed, a copy of the first element of sequence is placed in var, and the indented statements following the for statement are executed. Then the next element of sequence is copied to var, and the process repeats. This continues until all of the elements of sequence are used.

Finally, when the for loop processes all the elements of the sequence, the indented statements after the else statement are carried out. (Use of an else statement with a for loop is actually quite unusual.)

Here's a simple example of a for loop, to print out each element of a list:

>>> nums = [1,7,9,4,3] 
>>> for i in nums: 
... print(i) 
... 
1 
7 
9 
4 
3             
One of the most attractive features of the for loop is that we don't need to tell Python (or even know ourselves) how many elements are in the sequence that we're processing. The for loop figures that out automatically.

'Unpacking' with the for Loop

Another feature of the for loop that is sometimes useful involves unpacking the elements of a sequence. If the elements of the sequence that is being iterated over are themselves all sequences of the same length, the individual elements of the nested sequences can be unpacked in the for statement, which often makes programs more readable. Consider a list names, which contains tuples consisting of a last name and a first name:

>>> names = [('Smith','John'),('Jones','Fred'),('Williams','Sue')] 
To print each element of the list, with the first name preceding the last name, we could use a for loop as follows:

>>> for nm in names:
... print(nm[1] + ' ' + nm[0])
...
John Smith
Fred Jones
Sue Williams 
However, we could create a more readable program by unpacking the elements of the tuple in the for statement:

>>> for last,first in names: 
...     print(first + ' ' + last)
... 
John Smith 
Fred Jones 
Sue Williams                 

Limitations of the for Loop

The for loop is the basic tool for iterating over a sequence, but it trips up on a number of common tasks. For example, the for loop variable (referred to as var in the definition of the for loop) only represents a copy of the elements of a sequence, not the elements themselves. Thus, values in a sequence cannot be changed using a for loop without making a new sequence. Suppose we wish to replace numeric values that are stored in a list and are less than zero with the value 0. At first glance, it might seem that the following would work:

>>> nums = [3,7,-5,12,-9] 
>>> for i in nums: 
...     if i < 0 : 
...             i = 0 
... 
>>> nums 
[3, 7, -5, 12, -9]              
As you can see, changing the value of the loop variable did not permanently change the values in the list being processed. One solution is to make a copy of the list and to incorporate the changes in that copy.

>>> newnums = [] 
>>> for i in nums: 
...     if i < 0: 
...             newnums.append(0) 
...     else: 
...             newnums.append(i) 
... 
>>> newnums 
[3, 7, 0, 12, 0]            
Creating an entirely new list is a less-than-ideal solution, though.

The for loop also can't directly manipulate more than one sequence in parallel. Suppose we have a list of prices and a corresponding list of taxes, and we want to create a similar list called total that contains the sum of corresponding elements of the prices and taxes lists. Because the for loop is designed to process only one list at a time, it is awkward to use it for tasks such as this.

The range Function to the Rescue

The range function solves these sorts of problems. It accepts between one and three arguments, all of which are numeric.

With a single argument, range returns a list of integers starting at 0 and continuing to one less than the argument provided.
>>> list(range(5))
[0, 1, 2, 3, 4] 
With two arguments, it returns a list of integers starting at the first element and ending at one less than the second element.
>>> list(range(5,10))
[5, 6, 7, 8, 9] 
Finally, with three arguments, the third argument is used as an increment between successive values in the output list in place of the usual value of 1.
>>> list(range(0,20,5))
[0, 5, 10, 15]
As with sequence slices, the upper limit of the range function is never returned by the function; the range function is designed to work in conjunction with the subscripting of sequence elements, which begins at 0 and continues to one less than the length of the sequence. In particular, calling the range function with the length of a sequence as its single argument provides us with a list containing subscripts for each of the values in a sequence. We can then refer to these subscripts inside the loop to change the values of elements in the sequence or to process more than one sequence at a time.

So a solution to the problem of replacing negative values with zeros might be

>>> nums = [3,7,-5,12,-9] 
>>> for i in range(len(nums)): 
...     if nums[i] < 0: 
...             nums[i] = 0 
... 
>>> nums 
[3, 7, 0, 12, 0]                  
The range function also allows us to work with multiple lists.

>>> prices = [2.98,7.55,9.32,12.50]         
>>> taxes = [0.22, 0.57, 0.70, 0.94]         
>>> total = len(prices) * [0]       
>>> for i in range(len(prices)): 
...     total[i] = prices[i] + taxes[i] 
... 
>>> total 
[3.2, 8.12, 10.02, 13.44]                
To be able to refer to the ith element of total inside the loop, we had to make sure total contained enough elements to accommodate all the results before the loop was started. The square brackets around the 0 in the assignment of total ensured that Python would interpret the asterisk (*) as the list repetition operator and not the operator for scalar multiplication. Alternatively, the append method could be used on a list that was initialized to an empty list, as in a previous example.

The range function produces an actual list in memory containing all the elements specified through its arguments. If you use the range function with very large arguments, the amount of memory needed to hold all the elements that will be generated might be prohibitive. In those cases, you can use the xrange function, which works just like the range function but calculates its elements as needed, instead of storing them all in memory.

    
Instructo Note

    
Because xrange is considerably slower than range, you should use it only when absolutely necessary.
 
        
For repetitive computations that are not based on sequences, Python provides the while loop. Its basic syntax is as follows:

while expression: 
      statements 
else: 
      statements 
As with the other looping constructs, the colon on the while statement is required, and the statements following it must be correctly indented.

When Python encounters a while loop, it first tests the expression provided with the while statement. If the expression is true, the indented statements are executed, and the expression is tested once again. As long as the expression on the while statement is true, the statements will be executed repeatedly.

Finally, once the expression is evaluated to be false, the statements following the else statement, if present, are executed.

Notice that if the expression on the while statement is initially false, the statements following the while statement are never executed, and those following the else statement, if present, are immediately executed.

As with the for loop, else statements are not nearly as common with while loops as they are with if loops.

To illustrate the while loop, consider an iterative process to calculate the cube root of a number. It's not necessary to understand the underlying math (based on Newton's method); it suffices to understand that, starting from an initial guess, we can calculate a new, better guess through a simple computation. But instead of repeating the process a fixed number of times (which could easily be accommodated by a for loop), we want to continue refining our guess until our answer is reasonably close to the correct one. In the case of calculating the cube root, a convenient criteria is that the absolute difference between the number we're working with and our guess cubed is small, say 1.e-8. The following Python program uses a while loop to iteratively perform the calculation:

>>> num = 7. 
>>> oldguess = 0. 
>>> guess = 3. 
>>> while abs(num - guess**3) > 1.e-8: 
...     oldguess = guess 
...     guess = oldguess - (oldguess**3 - num) / (3 * oldguess**2) 
... 
>>> guess 
1.91293118277 
>>> guess**3 
7.0              
Notice that the variables num, guess, and oldguess were all assigned values with decimal points included to ensure that the calculations done with them would use floating-point arithmetic as opposed to integer arithmetic.

The 'Infinite' Loop

A common practice in many languages is to call a function that returns a 1 or True if it's successful and a 0 or False if it's not, and to use this assignment as the expression to be tested in a while loop. Python, however, does not allow assignment statements to be used like that, for two reasons.

Well-written Python functions don't communicate success or failure through return values. Instead, they use Python's try/except clauses to detect errors and take appropriate actions. (We'll discuss that error-detection technique in Module 7.)
Because the assignment operator (=) is almost identical to the operator for a test for equality (==), performing assignments as the expression in an if or while loop often leads to difficulty detecting errors.
For these reasons, many Python programs are written as "infinite" loops, and instead of relying on the expression given in the while statement, the break statement is used to terminate the loop. (We'll discuss the break statement in the next commentary topic.)

Although while loops are often terminated by the condition provided on the while statement, it's sometimes more natural to terminate a while loop after testing some condition inside the indented statements following the while statement. This is especially true in Python, because assignments cannot be used as the expression of a while statement. Also, unlike many other languages, Python does not provide a form of the while loop where the condition is tested at the bottom of the loop instead of at the top.

The break Statement

The break statement terminates a for or while loop without waiting for the expression given at the beginning of the loop to become false. When Python encounters a break statement inside a loop, it immediately stops executing the statements in the body of the loop and transfers control to the line in your program immediately following the loop, ignoring any else clause that might be present.

One of the most common uses of while loops is to read a file of unknown length. Suppose we want to find the longest line in a file. After creating a file object, we can read each line of the file, find its length, and compare that length to the longest length encountered up to that point. Because it's inconvenient to know the number of lines we'll need to process in advance, we can use a while loop and invoke the break statement when the readline method fails to return a line.

filename = 'myfile' 
try: 
    f = open(filename,'r') 
except IOError: 
    print("Couldn't open %s" %  filename)
maxl = 0 
while 1: 
    line = f.readline() 
    if not line: 
        break 
    if len(line) > maxl: 
        maxl = len(line)
print('Longest line had %d characters' % maxl)
  
When you use the value of 1 as the while loop expression, you must make sure that there is at least one break statement somewhere inside the body of the loop; otherwise the loop will continue forever, a condition known as an infinite loop. Here, we terminate execution of the loop when the readline method returns a value of None, signaling that it has reached the end of the file. In loops of this sort, an else clause is never used, because the loop will never exit due to the while loop's expression taking on a false value.

The continue Statement

You can use a continue statement in either a for or while loop to instruct Python to continue on to the next iteration of the loop without executing the statements in the loop that follow the continue statement. In a for loop, the value of the loop variable is incremented after a continue statement, so that after skipping the remaining part of the loop for the current iteration, the next iteration will be performed in the normal fashion.

Often, you can use a continue statement as an alternative to an if statement inside a loop. It's just a matter of personal preference as to which one to use. For example, suppose we want to find the largest number in a list, as well as the index within the list at which the largest value occurred. Using a continue statement, we could use the following:

>>> x = [7, 12, 92, 19, 18 ,44, 31] 
>>> xmax = x[0] 
>>> imax = 0 
>>> for i in range(1,len(x)): 
...     if x[i] <= xmax : continue 
...     xmax = x[i] 
...     imax = i 
...                                 
>>> print('Maximum value was %d at position %d.' % (xmax,imax))
Maximum value was 92 at position 2. 
We could obtain similar results by putting the last two statements of the for loop as the clause of an if statement to be carried out when a new maximum value is found. 

>>> for i in range(1,len(x)): 
...     if x[i] > xmax: 
...             xmax = x[i] 
...             imax = i 
... 
>>> print('Maximum value was %d at position %d.' % (xmax,imax))
Maximum value was 92 at position 2.  


---- 6

In Python, functions are just another type of object. You can

assign a function to another name
store functions in lists, tuples, or dictionaries
pass functions to other functions
What sets functions apart from other Python objects is that you can provide them with a parenthesized list of arguments, and they will perform a task using those arguments as a guide to what needs to be done. We've already seen a number of functions: len, min, max, and others. We have also seen methods, which are a lot like functions and are used in a similar way.

In Python, there's very little difference between a function that is part of Python itself and the functions that you write, so you should be able to start writing and using functions very quickly. Let's look at what is involved.

The def statement is the signal to Python that you're defining a function.
You follow the def keyword with the name of the function and a parenthesized list of the arguments that the function will accept, finally followed by a colon as the very last character on the function definition line.
If the function you are writing takes no arguments, you must still include a pair of empty parentheses after the function name. One especially appealing feature of functions in Python is that, if you include a quoted string starting on the line immediately following the line containing the def statement, it will be stored along with the function. Such a string is known as a docstring, and it can be accessed as the __doc__ attribute of the function. You can access this docstring in the Python interpreter by using the help function introduced in Python 2.2.
Following the definition line and optional docstring is the function body. The body of a function must be indented the same way as the body of a loop.
When you call a function, control is returned when a return statement is encountered -- or when the function reaches the end of its (indented) body of code.
If an expression appears after a return statement, the value of that expression is returned to the calling program through the function call. If an expression appears (or there isn't a return statement anywhere in the function body), the function returns a value of None.
As an example of a function, consider the task of merging two lists to form a third list that contains all the elements that are in either the first or second list. We could define such a function as follows:

def merge(list1,list2): 
    '''merge(list1,list2) returns a list consisting of 
the original list1 along with any elements of list2 
that were not already in list 1''' 
    newlist = list1[:] 
    for i in list2: 
        if i not in newlist: 
            newlist.append(i) 
             
    return newlist 
After defining this function, we could view its docstring as follows:

>>> print(merge.__doc__) 
merge(list1,list2) returns a list consisting of 
the original list1 along with any elements of list2 
that were not already in list 1  
    


    
Note that inside the function, newlist was created from list1 using a slice instead of just the list's name, to make sure that a true copy was made. The return statement is necessary because the goal of the function is to return a new list whose contents are formed by merging the two original lists.
 
        
Calling a Function

To call a function, refer to its name along with a parenthetical list of arguments. If the function takes no arguments, you still need an empty set of parentheses so that Python can recognize the expression as a function call and not a variable.

Arguments to functions behave in a similar way to arguments in an assignment statement. Modifying a scalar or a mutable object that was passed to a function through the argument list will not permanently change that object. But modifying an element of a mutable object (like a list or dictionary) passed to a function will change the elements after you've returned back to the calling environment.

The following program gives an example of how the merge function could be called:

>>> one = [7,12,19,44,32] 
>>> two = [8,12,19,31,44,66] 
>>> print(merge(one,two)) 
[7, 12, 19, 44, 32, 8, 31, 66] 
>>> print(one) 
[7, 12, 19, 44, 32]  

The LGB Rule

Python uses what is sometimes known as the "LGB rule" to resolve references to variable names.

Inside a function, namespaces are searched in the following order:

Local
Global
Built-in
Starting with version 2.2, in the special case of a function defined within a function (a nested function), if the name is not resolved in the local, global, or built-in namespaces, Python will then search the local namespace of the function within which the function is nested.

    
Instructor Note

    
Section 10.7 of your textbook, beginning on page 123, explains the concept of namespace and illustrates the LGB scoping rules.
 
        
The global Statement

While Python's scoping rules generally enforce good programming, you may occasionally find a situation where they prevent you from achieving your goals. Object-oriented techniques that we'll look at later in the course provide a solution to such problems. But at this point we'll discuss how some of Python's scoping rules can be overridden with the global statement.

When you declare a variable as being global inside a function, Python doesn't bother to create an entry in the local namespace; it resolves references to that variable through the global namespace.

The local namespace consists of variables that are created and set to a value inside the function, while the global namespace consists of variables created in your program outside of any functions.

One situation in which a global variable may be useful is when you want to count the number of times a function is called in your program. Notice that if you try to use a local variable as a counter, its value will be overwritten each time you call the function, so a global variable may be a good choice.

count = 0
def doit(x): 
        global count 
        count = count + 1 
        return x + 1
tst = [10,19,25,18,17,23,29] 
print(tst) 
for i in range(len(tst)): 
        if tst[i] % 2 == 1: 
                tst[i] = doit(tst[i]) 
print(tst)
print('doit was called %d times.' % count) 
If you don't modify a variable inside a function, the LGB rule will find that variable's value if it's already been set in the global scope, but if you want to modify such a value, you need to explicitly state your intention through the global statement.

    
Instructor Note

    
Most programmers agree that global variables make your programs more difficult to understand, so you should use them only when absolutely necessary.
 
        
When you define a function, each argument passed to that function must have a name. But you don't have to use those names when calling the function. When arguments are passed to a function without using names for the arguments, Python assumes that you've entered the arguments in exactly the order in which they were defined. To illustrate, consider a function that counts the number of times a letter appears in a string.

def count_letter(string,letter): 
    count = 0 
    for i in string: 
        if i == letter: 
            count = count + 1
    return count                           
If you accidentally passed the letter to count_letter before the string, the function would simply return 0, unless the letter and string happened to be the same. To make it easy to avoid such mistakes, you can precede some or all of the arguments by a name and an equal sign. This signals to Python exactly which arguments each value represents. For example, we could invoke the count_letter function as follows, with no fear that the arguments would be misunderstood:

num = count_letter(letter='a',string='dead parrot')
    
Instructor Note

    
When you provide names for only some of the arguments to a function, the named parameters must follow the unnamed parameters, and Python assigns the unnamed parameters in the order they appear in the argument list in the function definition. Thus, when writing a function, it's a good idea to put the required arguments (the ones that must be given every time the function is called) before the optional arguments in the argument list.
 
        
To provide greater flexibility when defining a function, Python allows you to specify a default value for any or all of the arguments by following the name of the argument in the argument list with an equal sign and a value. This is similar to the way you set named arguments to a value when you call a function. Using the count_letter function as an example, suppose we want by default to count the number of blanks in a string. We could supply this default value as follows:

def count_letter(string,letter=' '): 
    count = 0 
    for i in string: 
        if i == letter: 
        count = count + 1
    return count                      
Now, when we call count_letter with only one argument, Python will use the default value of blank (' ') as the letter to count. Keep in mind that if you explicitly specify a letter= argument, or if you call the function with two arguments, the default will be ignored, and the value you specify in the argument list will be used. Thus, the following calls to the function will each count the number of blanks in a string:

mystring = 'this parrot is dead' 
count_letter(mystring,' ') 
count_letter(mystring) 
count_letter(letter=' ',string=mystring)     
Now we'll extend the count_letter function to create a new function that will allow us to change a character in a string to some other character. Since strings are immutable, we can't change the string directly; we'll first convert it to a list, make the necessary changes, and reconstruct the string from the list elements. Because we'll always need a string, we'll make that the first argument and not provide any default. The two additional arguments (the character we're changing and the character to which we're changing it) will follow, and we'll provide them with defaults.

def change_letter(string,frm=' ',to=''): 
    lstring = list(string) 
    newstring = '' 
    for i in lstring: 
        if i == frm: 
           newstring = newstring + to 
        else: 
           newstring = newstring + i
    return newstring 
    


    
Notice that we couldn't use the name "from" as an argument to the function, since it is a reserved word in Python. The default arguments have been selected so that when only a string is passed to the function, it will remove blanks from the string.
 
        
Here are some examples of how we could call the change_letter function:

>>> change_letter(mystring) 
'stringwithblanks' 
>>> change_letter(mystring,to='+') 
'string+with+blanks' 
>>> change_letter(mystring,to='X',frm='a') 
'string with blXnks' 
However, if we try to call the function with a named argument before the unnamed argument, we will raise an exception.

>>> 
  change_letter(frm='b','string with blanks')

  SyntaxError: 
    non-keyword arg after keyword arg 
To change the order of the arguments, we'd need to name all of the parameters we use.

>>> 
  change_letter(frm='b',string='string with blanks')

  'string 
    with lanks' 

In some situations, at the time you are writing a function, you can't predict how many arguments will be passed to it.

One solution is to insist that all the arguments are put into a list or dictionary before being passed to your functions, but this puts an extra burden on the user of your programs and should usually be avoided.

Instead, when Python encounters an argument in a function definition that is preceded by an asterisk (*), it collects any unnamed arguments into a tuple that can be accessed through that argument's name (without the asterisk). Of course, only one such argument can appear in a function definition.

As a simple example, consider a function that will find the longest of a variable number of string arguments. We'll use the name strings as the special argument to hold unnamed arguments.

def longlen(*strings): 
   max = 0 
   for s in strings: 
     if len(s) > max: 
        max = len(s)
   return(max)             
Note that inside the function, strings is just an ordinary tuple; we only need to specify the asterisk in the function definition. By using this technique, we can accept as many or as few arguments as the user of the function provides.

>>>longlen('apple','banana','cantaloupe','cherry')
10
>>> longlen('parrot')
6
>>> longlen()
0 
The technique of using a single asterisk before an argument name in a function definition allows us to write functions that take an unlimited number of unnamed arguments.

But what about named arguments? A similar technique -- preceding an argument name with two asterisks -- informs Python to collect named arguments into a dictionary that can be accessed through the argument's name (without the leading asterisks). Only named arguments that are not explicitly defined in the function definition will be included in that dictionary, so you can still handle required arguments in the usual way when using this feature.

To illustrate that idea, we'll look at a trivial program that simply prints the values of all the arguments that are passed to it. Note that in the function, two "normal" arguments, a and b, are defined; they are not included in the dictionary created by the special argument, dict.

def printargs(a,b,**dict): 
    print('a=%s' % a) 
    print('b=%s' % b) 
    for k in dict.keys(): 
        print('%s=%s' % (k,dict[k]))    
Here are the results of a simple test of the function:

>>>printargs(x='seven',a='six',b='five',next='four',last='three')
a=six
b=five
next=four
x=seven
last=three 

Instructor Note

 
Note that the arguments a and b need to be treated separately from the other named arguments, since they were explicitly specified in the function definition.
 
        
You can combine both types of special arguments in the same function. That allows a great deal of flexibility in the way arguments can be passed to your functions. Once again, a trivial example will illustrate the general idea. When you use either of the special arguments (single or double asterisks), they must be the last arguments in the argument list. If both are present, the single-asterisk argument should precede the double-asterisk argument.

def allargs(one,*args,**dict): 
    print('one=%s' % str(one)) 
    print('Unnamed arguments:') 
    for a in args: 
        print('%s' % str(a)) 
    print('Named arguments:') 
    for k in dict.keys(): 
        print('%s: %s' % (k,str(dict[k])))               
Since there is one named argument in the function definition (one), the allargs function must be called with at least one argument, or an exception will be raised.

>>> allargs() 
Traceback (innermost last): 
  File "", line 1, in ? 
TypeError: not enough arguments; expected 1, got 0             
When allargs is called with exactly one unnamed argument, neither of the special arguments receives anything, because Python will interpret the single argument as being the explicitly defined element one.

>>>allargs('one')
one=one
Unnamed arguments:
Named arguments: 
When the function is called with multiple named or unnamed arguments, the special arguments will receive all but the first argument.

>>>allargs('spam','sausage',meat='bacon',entree='eggs')
one=spam
Unnamed arguments: 
sausage
Named arguments:
entree: eggs
meat: bacon

The map Function

Lists are the basic data structure of Python, so it's not surprising that there are many situations where you'll want to perform the same operation on every member of a list.

For example, suppose we've used the readlines method to read all the lines of a file into a list called thelines, and we want to remove the newlines from each of the lines stored in the list elements. We've seen how to do this using list methods and a for loop.

for i in range(len(thelines)): 
      thelines[i] = thelines[i][:-1]  
Python provides an alternative to the for loop in these cases, namely the map function. The map function is different than most functions in that it requires a function as its first argument and one or more lists as additional arguments. When invoked, map calls the function using each element of the list(s) as the arguments to the function in turn. Then map returns a view object containing the result of those function calls. Thus, the length of the lists passed to map must be the same, and the number of lists passed to map must be equal to the number of elements that the function passed to map expects. 
To remove newlines from each element of a list, we could create a function like this:

def rmnewline(line): 
      return line[:-1]  
Then we could use map as follows:

thelines  = list(map(rmnewline,thelines))  
While no extra functionality is provided, many programmers find map to be more convenient than looping in some situations, which I'll illustrate below.

As an example of calling map with more than one list, suppose we have one list of first names and a second list of last names, and we wish to join them in a third list. Once again, we could use a for loop.

>>> first = ['Joe','Sue','Harry'] 
>>> last = ['Smith','Williams','Brown'] 
>>> both = [] 
>>> for i in range(0,len(first)): 
...     both.append(first[i] + ' ' + last[i]) 
...
>>> both ['Joe Smith', 'Sue Williams', 'Harry Brown']
Notice that we need to initialize the list containing the result (both) as well as worry about the length of the lists.

In situations like the previous example, where a function is used only once, Python provides the lambda operator to produce what are known as anonymous functions. Anonymous functions must be composed of just a single statement, which will be the return value of the function; thus, no return statement is used. Instead of providing the argument list surrounded by parentheses, you just follow the word lambda with a comma-separated list of arguments. Our previous example could then be simplified to 
>>>  both = list(map(lambda x,y:x + ' ' + y,first,last))
The filter Function

Another functional programming tool in Python is filter. Like map, filter's first argument is a function, and its second argument is a list. But filter returns a view object containing only those elements of the list for which the function passed to filter returns a value of true. For example, to eliminate negative numbers from a list, we could use filter as follows:

>>>  nums = [-3,7,12,-2,19,-5,7,8,-3]
>>> list(filter(lambda x:x > 0,nums))
[7, 12, 19, 7, 8] 

As an alternative to the functions map and filter, list comprehensions were added to Python in release 2.0.

List comprehensions allow you to create a new list as a result of operating on each element of an existing list. They give you the ability to conditionally select the elements of the existing list that will be returned in the new list.

In addition, list comprehensions do not require a function to be called for each element of the list; you simply specify the expression that performs the operation that you want carried out.

The basic form of a list comprehension is

[expression for var-1 in seq-1 if condition-1 for var-2 in seq-2 if condition-2 ...]  
The if keyword and its corresponding conditions are optional, as are all of the for constructions except the first. The result of a list comprehension is a list with expression evaluated for each combination of values var-1, var-2, . . . that meet any if conditions that are specified.

In its simplest form, with only one for clause, a list comprehension works like the map function but without the need to specify a function to do the work. Consider the following piece of Python code, which adds 10 to each element of a sequence:

>>> values =  [-3,7,12,-9,18,-5,3]
>>>  list(map(lambda x:x + 10,values))
[7, 17,  22, 1, 28, 5, 13] 
We can achieve the same functionality by using a list comprehension.

>>> [x + 10 for x in values]
[7, 17, 22, 1, 28, 5, 13] 
Note that, by using an if statement, a list comprehension can do the job of a call to filter embedded inside a call to map. In the previous example, suppose we only wanted to operate on values that are greater than 0. We could write a list comprehension as

>>> [x + 10 for x in values if x > 0]
[17, 22, 28, 13] 
This is equivalent to the following combination of filter and map:

>>> list(map(lambda x:x + 10,filter(lambda x:x > 0,values)))
[17, 22, 28, 13] 
But list comprehensions differ from their functional programming counterparts in the way they handle multiple sequences. Recall that, when the map function is called with multiple sequences, all the sequences must be of the same length, and the list returned from map will be of the same length as all the input sequences. When you use multiple sequences with a list comprehension, the expression being evaluated by the comprehension is evaluated for all possible combinations of the elements of the multiple sequences (assuming that no combinations were excluded due to the use of if clauses). Notice the difference between the following two Python expressions:

>>> one = 'abc'
>>> two = '123'
>>> list(map(lambda x,y:x + y,one,two))
['a1', 'b2', 'c3']
>>> [x + y for x in one for y in two]
['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3'] 
In fact, there's no reason that the sequences operated on by a list comprehension need to be of the same size.

>>> days = ['mon','tue','wed','thu','fri']
>>> times = ['am','pm']
>>> [(i,j) for i in days for j in times if i != 'fri' or j != 'pm']
[('mon', 'am'), ('mon', 'pm'), ('tue', 'am'), ('tue', 'pm'), ('wed', 'am'), ('wed', 'pm'), ('thu', 'am'), ('thu', 'pm'), ('fri', 'am')] 
Like the functional programming tools, any expression using list comprehensions could be replaced with statements consisting of one or more loops, so the choice of whether to use them or not is strictly a personal one.

------ 7

Whenever you use a try/except clause, the programming statements contained in the try portion of the clause are executed in a "protected" environment, in the sense that errors occurring in that code will not necessarily cause Python to terminate. Instead, you have the opportunity to catch and examine the error, then take the action of your choice. You can use an optional finally clause after one or more except clauses to specify instructions to be carried out regardless of whether an exception is raised.

Perhaps the classic example of the use of the try/except clause is to catch problems when you attempt to open a file. Let's take a look at what happens when we try to open a file that doesn't exist:

>>> f = open('not.a.file') 
Traceback (innermost last): 
  File "", line 1, in ? 
IOError: [Errno 2] No such file or directory: 'not.a.file' 
Notice that it's the built-in open function that generates the exception. All built-in functions and methods will generate exceptions when they encounter a problem.

The traceback contains useful information. First, it displays the line and file in which the error was encountered. While this is not very useful in an interactive session, it is invaluable when running Python programs from a file. The final line of the traceback is especially important when considering how to deal with problems that might arise in your program, because it gives the name of the exception that was encountered.

Many exceptions also provide specific information about the nature of the exception, like the No such file or directory message in this example. You can capture this additional information in a variable by specifying the name of that variable after the name of the exception, separated by a comma.

>>> try: 
...     f = open('not.a.file') 
... except IOError as msg: 
...     print(msg) 
...  
[Errno 2] No such file or directory: 'not.a.file' 
If Python encountered this code in a program it was executing, the program would not terminate after failing to open the file, since the IOError was trapped. In many situations, when you encounter an exception, you'll want to terminate your program by calling the exit function of the sys module.

Although it's common to have only a few statements in the try portion of a try/except clause, it is possible to include a larger block of code and then organize all the exception handling for the block in a series of except clauses after that block of code.

As a simple example, suppose we have a dictionary that maps a user's name to the location of a file with information about the user. Given a user's name, our program will look up the file name in the dictionary and then print the file. In the course of doing this, two different exceptions may arise.

First, if the user is not in the dictionary, then a KeyError exception will be raised.
If the file can't be opened, then an IOError exception will be raised.
One approach is to catch both of these errors in a single except clause.

userdict =  {'john':'/home/john/infofile', 
       'sue':'/users/sue/sue.info', 
       'fred':'/home/fred/info.fred' }
user = 'joe' 
try: 
      thefile = userdict[user] 
      print(open(thefile).read())
except (KeyError,IOError): 
      print('Error getting information for  %s' % user, file=sys.stderr)
Alternatively, each exception may be dealt with individually.

import sys

try: 
      thefile = userdict[user] 
      print(open(thefile).read())
except KeyError: 
      print('No information for %s is  available' % user, file=sys.stderr)
except IOError as msg: 
      print('Error opening %s: %s' %  (thefile,msg), file=sys.stderr)
When you use multiple except clauses, Python will execute the code in the first clause it encounters for which that exception has been raised, and then execute the code after the entire try/except construction (unless, of course, the code in the except clause resulted in the program terminating).

In the previous example, notice that any exception other than a KeyError or an IOError will be handled in the usual way; namely, Python will print a traceback and exit. You can catch all types of errors by including an except statement with no exception name. While this will prevent termination of your program, it may not be the best strategy in all situations, because different errors often need different remedies. In particular, even syntax errors will be trapped by an except clause without an exception name.

When you have several except clauses as part of a try/except construct, and an exception is raised, the statements after the first except clause that is matched will be executed. Usually this will not cause any surprises, but Python does have a hierarchy of exceptions. Exceptions higher in the hierarchy will be activated even though they are not an exact match for the exception that has been raised.

The following list of exceptions illustrates the hierarchy. Exceptions that are indented below other exceptions will be caught by the less indented exception as well as through their own names.

 
BaseException
  +--  SystemExit
  +--  KeyboardInterrupt
+-- Exception
     +--  StopIteration
     +--  ArithmeticError
     |    +-- FloatingPointError
     |    +-- OverflowError
     |    +-- ZeroDivisionError
     +--  AssertionError
     +--  AttributeError
     +--  BufferError
     +--  EnvironmentError
     |    +-- IOError
     |    +-- OSError
     +--  EOFError
     +--  ImportError
     +--  LookupError
     |    +-- IndexError
     |    +-- KeyError
     +--  MemoryError
     +--  NameError
     +--  ReferenceError
     +--  RuntimeError
          +--  NotImplementedError
     +--  SyntaxError
     |    +-- IndentationError
     |        +-- TabError
     +--  SystemError
     +--  TypeError
     +--  ValueError
          +-- UnicodeError
              +-- UnicodeDecodeError
              +-- UnicodeEncodeError
              +-- UnicodeTranslateError
For example, the EnvironmentError exception will catch both IOErrors and OSErrors. Thus, when you create try/except clauses in your programs, the ordering of the exceptions may affect they way that their corresponding code is called.

Continuing with the EnvironmentError example, if an except clause for an OSError appeared after an except clause for an EnvironmentError within the same try/except construction, the OSError clause would never be activated. That's because the EnvironmentError would intercept the exception, and only one exception per try/except construct will ever be activated.

On the other hand, if the EnvironmentError clause appeared after the OSError clause, it would be activated when an IOError was raised, since that exception is below EnvironmentError in the exception hierarchy.

So far in this module, our focus has been on trapping exceptions generated by built-in functions and methods, and deciding on reasonable courses of action. In addition to responding to exceptions in other functions, you can raise exceptions in your own functions. (If you're calling other built-in functions, any exceptions that they raise will "filter up'' through your own functions, so there's no need to explicitly raise an exception in such a situation.)

You can raise any of the existing exceptions, or you can create new ones of your own. In the previous topic, we saw all the built-in exceptions. You can also find their names by examining the directory of the +__builtins__+ object; all the exceptions contain the string "Error'' or "Exit''.

You can create your own exceptions as subclasses of the built-in Exception class, which is the basis for all exceptions in Python. (Creating and working with classes is described in detail in Module 10.) For example, to create a new exception called MyError, you can use the following code:

class MyError(Exception): 
   pass 
The pass statement serves as a placeholder in situations when Python expects a statement, but you don't need any further details to create a usable exception.

After creating an exception, you can use the raise statement to activate it. Suppose we are writing a function that will create an archive of files on a 100 MB Zip disk. Before writing the archive, we will check to make sure that all the files will fit on the disk; if they will not, we'll raise a SizeError exception. In this way, the calling program can decide what action is appropriate. Here is the code to define the exception and create the archive:

import shutil,os
class SizeError(Exception): 
    pass
def mkarchive(dir,capacity=100*1024*1024): 
  
    files = os.listdir(dir) 
    totalsize = 0  
    for f in files: 
        totalsize = totalsize + os.getsize(os.path.join(dir,f)) 
        if totalsize > capacity: 
            raise SizeError(dir)
    for f in files: 
        shutil.copy(os.path.join(dir,f),os.path.join('/zip',f)) 
    
Instructor Note

    
Note that the copy function may very well raise exceptions of its own; however, since we've defined our own SizeError exception, we'll be able to distinguish between the two types of errors.
 
        
Now consider how we might use this function. Suppose we're going to create several archives, with a program that will prompt us to change disks between each archive. The following program would repeatedly call the mkarchive function, printing appropriate status messages after each call:

dirs = ['/home/joe/papers','/home/sue/backup','/home/fred/save']  
for dir in dirs: 
    print('Insert blank disk and hit return ') 
    sys.stdin.readline()
    try: 
         mkarchive(dir) 
         print('Archived %s to zip disk' % dir)
    except SizeError as msg: 
         print('Directory %s too large for zip disk' % msg)
    except IOError as msg: 
         print('Error archiving directory %s : %s' % (dir,msg)) 
Notice that the print statement after the call to mkarchive will only be executed if no exception was encountered in the function call.

    
Instructor Note

    
When you write a script or program that will be used by others, it's a good idea to catch any exceptions that might be raised by the functions and methods that you call.
For example, if you've written a script that will go to a Web site, download the contents of a Web page, and extract information from it, you should attempt to open the Web site inside a try/except clause. Then, if there is a problem, instead of letting the exception result in a traceback, you should print a descriptive error message and exit gracefully. With a well-written program, an end user not familiar with Python should never see a traceback.
When you are writing a function that will be used inside others' programs, however, it is usually better to let exceptions rise up to the caller, rather than try to handle them yourself. Continuing the Web page example, suppose you've written a function called checkpage that accepts a URL and returns some useful information. As a caller of this function, I might want to try a particular Web site, and, if it wasn't successful, try an alternative site.
found = 0 
try: 
      info = checkpage("http://some.location.org/index.html") 
      found = 1 
except IOError: 
      info = checkpage("http://other.location.org/index.html") 
      found = 1
 
        
While it's natural to think of raising exceptions when an error is detected, you can use exceptions in other situations as well. We've already seen an example of this in Topic 3.10, where I presented exceptions as one method to determine whether a dictionary had a value for a particular key. In that case, exceptions were just one of a number of available possibilities, but there are some situations where exceptions are the only way to solve a problem.

For example, the walk function, which is part of the os module, will traverse a directory and call a user-written function each time a new directory is encountered. Suppose we want to write a program to search for a file with a particular name, but we'd like the program to stop searching as soon as it finds such a file. We could exit the program entirely (by calling sys.exit), but without exceptions, there's no way to simply return from the walk function until all the directories have been traversed.

We could create an exception, raise that exception once the filename has been found, and put the call to walk inside a try/except loop. The following program implements that strategy:

import os  
class  FoundException(Exception): 
      pass
def chkname(name,dir,files): 
       if name in files: 
           raise FoundException(os.path.join(dir,name))
name = 'errno.h' 
startdir = '/usr/include' 
try: 
      for (path, dirs, files) in os.walk(startdir):
           chkname(name, path, files)
       print('%s not found starting at %s' % (name,startdir))
except FoundException as pathname: 
       print('%s found: %s' % (name,pathname)) 
A similar strategy can be employed to make a "panic'' exit from inside deeply nested loops.

To use a module, you must expand the namespace of your program to include the objects that are defined in that module. There are two ways to do this, each using the import statement. To make these ideas more concrete, we'll consider the shutil module, which provides functions high level file operations such as copying and removal.

The simplest way to access a module is to provide the module's name in an import statement somewhere near the beginning of the program in which you'll be using the module. In the current context, that would mean including the line

import shutil 
somewhere near the beginning of the program. You can import more than one module in a single import statement by separating the names of the modules with commas, or you can use multiple import statements.

When you use this form of the import statement, the only name that is imported into the current namespace is shutil. In order to access individual objects (like functions) that are contained within the shutil module, you'd need to further qualify the shutil reference with the name of the object you wish to reference, and insert a period (.) between the module name and the object name. After using the import shutil statement, you can list the names of all its objects with the dir function:

>>> import shutil
>>> dir()
['__builtins__', '__doc__', '__name__',  '__package__', 'shutil']
>>> dir(shutil)
['Error', '__all__', '__builtins__',  '__doc__', '__file__', '__name__', 
'__package__', '_basename', '_samefile',  'abspath', 'copy', 'copy2', 
'copyfile', 'copyfileobj', 'copymode', 'copystat',  'copytree', 
'destinsrc', 'fnmatch', 'ignore_patterns', 'move', 'os', 'rmtree',  
'stat', 'sys']
With the shutil module now imported, you can call its methods. In the statement below, the file1.txt is moved to the directory category using the shutil's move method:

shutil.move('file1.txt', 'category/file1.txt')
An alternative method of making a function from a module available to your program is to import the name of the function directly into the current namespace, so that you can refer to it without any qualifying module name. Following the above example, you could import shutil directly into the current namespace with the command

from shutil import move 
To import more than one name from a module directly into the current namespace, simply provide the names as a comma-separated list. After using the above form of the import statement, you could access the move function directly.

move('file1.txt', 'category/file1.txt')
    
Instructor Note

    While this approach is more direct, it eliminates the direct connection between the move function and its parent module. You'd need to check near the beginning of the program to find the import statement that was used to bring move into the current namespace in order to determine from which module it came. Furthermore, you need to list the name of each function you wish to import on the import statement. Since the module's name was not imported into the current namespace, you can't refer to other objects from the module or use the dir command to find out their names.    
        

Finally, you can import all the objects in a module into the current namespace with a command like this:

   from  modulename import *
Since this technique may overwrite existing objects (including built-in ones), it should be used with great care. Once all the objects from a module have been imported into the current namespace, there's no easy way to tell where a particular object came from. Generally, the only time this method is useful is when the author of a module has purposely named the objects in the module so that they can all be safely imported. In these cases, the documentation for the module should make it clear that the technique of importing all of the object's names into the current namespace is appropriate.

(As of version 2.0, most of the functionality of this module has been replaced by methods that are available for string objects. If you are using an older version of Python, you will need to use the functions described here; otherwise, you should try to migrate your programming to utilize the string methods described previously, because the functions in the string module will eventually become unsupported.)

digits

The string module contains a variety of constants and functions that are useful when working with strings. One constant, digits, is a list containing

string representations of the ten decimal digits
three lists: uppercase, lowercase, and letters, which contain the twenty-six uppercase letters of the alphabet, the twenty-six lowercase letters of the alphabet, and the union of the two, respectively
These lists are useful when we want to verify that all the characters in a string are of a particular type. For example, suppose we have a string called code that is supposed to consist entirely of numbers. We could verify that this is the case by using a function like the following:

import string 
def checknum(code): 
    for i in code: 
        if i not in string.digits: 
          return False
    return True 
split and join

Perhaps the two most useful functions in the string module are split and join.

The split function accepts a string and returns a list of the words in the string. With no second argument, split uses any number of whitespace characters (blanks, tabs, formfeeds, or newlines) as a separator between words. When a second argument (also a character string) is used, that argument is used as the separator. With a second argument, every occurrence of the separator will define a new word, and multiple consecutive separators will create empty fields, as the following example shows:

>>> import string 
>>> mystr = 'one two   three four    five' 
>>> mystr.split() 
['one', 'two', 'three', 'four', 'five'] 
>>> mystr.split(' ')
['one', 'two', '',  '', 'three', 'four', '', '', '', 'five']
In the default case, any number of blanks serve as a separator, whereas when a blank is explicitly provided as the separator, fields separated by multiple blanks produce empty strings in the output text. If necessary, you can remove these empty strings by using the filter function with a first argument of None. Note that filter returns a view object.

>>> mystr = 'one two   three four    five' 
>>> parts = mystr.split(' ') 
>>> parts 
['one', 'two', '', '', 'three', 'four', '', '', '', 'five'] 
>>> list(filter(None,parts))
['one', 'two', 'three', 'four', 'five']  
Finally, an optional second argument (maxsplit) limits the number of elements in the list returned by split.

>>> mystr = 'one two   three four    five'
>>> parts = mystr.split(' ', 3)
>>> parts          
['one', 'two', '', ' three four    five']
>>> list(filter(None,parts))
['one', 'two', '  three four    five'] 
The function join provides the opposite functionality of split. It accepts a sequence of strings and joins them together, returning a single string. The object string will be the string separator. As a simple example of the use of join, consider producing comma-separated data suitable for input to a spreadsheet program:

>>>  values = (120.30,250.19,191.32,415.19)
>>> ",".join(values) 
>>> ",".join(map(str,values))
'120.3,250.19,191.32,415.19' 
Because the first argument to join must be a sequence of strings, the map function was used to convert the numeric list (values) to a list of strings.

Removing Whitespace

The string module provides three functions for removing whitespace from strings.

lstrip
rstrip
strip
These remove leading, trailing, and both leading and trailing whitespace from a string, respectively.

Each of the functions accepts a string and returns the string with whitespace (blanks, tabs, newlines, and formfeeds) appropriately removed.

Capitalization

A variety of functions deal with capitalization.

The capitalize function returns its input string with the first letter capitalized. If the first letter is already capitalized, the original input string is returned.
The swapcase function accepts a string and returns a string with the case of each character in the original string reversed. (Uppercase becomes lowercase and vice versa.)
The upper function returns a string with all the characters of its input string converted to uppercase.
The lower function does the same but returns a string of lowercase characters.

Regular expressions are a special way of defining, searching for, and modifying patterns that appear in text. As a first approximation, you can think of regular expressions as being literal pieces of text, for example "cat" or "1.00." At a more complex level, they can be used to describe patterns, such as "a number followed by a capital letter, followed by a character that's not a dash."

The re module provides functions for defining regular expressions, searching strings for the presence of regular expressions, and substituting different text for a regular expression.

Even though the complexities of regular expressions may take a long time to master, you can start using simple regular expressions in your Python programs right away. Anytime you're processing text, and the limitations of the usual comparison operators become apparent, regular expressions will generally provide a simple answer to your problems. Even though the re module is not part of the core Python distribution, if you work with text, you'll find that this module is the key to writing efficient and effective programs.

Regular expressions in Python are strings containing three types of characters.

literal characters, which represent a single character
character classes, which represent any one of several different characters
modifiers, which operate on characters, character classes, or combinations of the two
Literal characters include digits, upper- and lowercase letters, and the characters listed in the Special Character Sequences table in Module 2, Topic 2.1. Because many of the usual punctuation characters have a special meaning when used in regular expressions, when you need to use one of them in a regular expression, you have to precede it with a backslash (\). The characters are

.
^
$
+
?
*
(
)
[
]
|
In addition, because backslashes need to be interpreted literally by the regular expression routines, you will generally use raw strings (denoted with the character r, also discussed in Topic 2.1) when you construct a regular expression.

The Character Class

A character class is represented by one or more characters surrounded by square brackets ([]). When Python encounters a character class in a regular expression, it will match the expression with an occurrence of any of the characters within the character class. Ranges of characters (like a-z or 5-9) are allowed in character classes. (If you need to specify a dash inside a character class, make sure that it is the first character in the class, so that Python doesn't confuse it with a range of characters.)

If the first character in a character class is a caret (^), then the character class is matched by any character except those listed within the square brackets.

As a useful shortcut, Python provides some escape sequences that represent common character classes inside regular expressions. I've listed those sequences in the table below.

Symbol
Matches
\w
Alphanumerics and _
\W
Non-alphanumerics
\d
Digits
\D
Non-digits
\s
Whitespace
\S
Non-whitespace
As I mentioned previously, certain punctuation symbols have special meanings inside regular expressions.

The caret (^) indicates the beginning of a string.
The dollar sign ($) indicates the end of a string.
Within a regular expression, parentheses can be used to group several characters or character classes.
The Modifier

A number of characters known as modifiers (listed in the table below) can be used within regular expressions.

Modifier
Meaning
.
Matches any single character except newline
|
Separates alternative patterns
*
Matches 0 or more occurrences of preceding entity
?
Matches 0 or 1 occurrences of preceding entity
+
Matches 1 or more occurrences of preceding entity
{n}
Matches exactly n occurrences of preceding entity
{n,}
Matches at least n occurrences of preceding entity
{n,m}
Matches between n and m occurrences
Modifiers can follow a character, character class, or a parenthesized group of characters and/or character classes, and they can expand the range of what will be matched by the entity that precedes them. For example, the regular expression cat would only be matched by a string containing those specific letters in the order given, while the regular expression ca*t would be matched by strings containing sequences such as ct, caat, caaat, and so on.

Before Python can actually search for a regular expression in text, it must process the regular expression by a technique known as compilation. Once the expression is compiled, Python can search for it very rapidly, even in a long string of text. When you use regular expressions in Python, you can either

compile them once and invoke methods appropriate for the compiled expression, or
have Python compile the regular expression each time you call a function to search for a regular expression.
If you're going to repeatedly search for a regular expression that won't be changing each time you use it, you'll see faster performance if you compile the regular expression once and repeatedly invoke methods on the compiled expression. Furthermore, when you compile a regular expression, you can specify options that change the way Python will treat your regular expression. Those options, which are defined as attributes of the re module, are listed in the table below.

Short Name
Long Name
Purpose
I
IGNORECASE
Non-case-sensitive match
M
MULTILINE
Make ^ and $ match beginning and end of multiple lines within string
S
DOTALL
Allow . to match newline
X
VERBOSE
Ignore comments and unescaped whitespace
Options are passed as the final argument to the compile function of the re module. To specify more than one option, join the options with the bitwise or operator (|).

Suppose we want to search for e-mail addresses in a set of strings. As a simple approximation, we'll assume that e-mail addresses are of the form user@domain. Because such a pattern will not change each time we use it, it would be efficient to compile the regular expression before using it, by making the following call:

emailpat = re.compile(r'.+@.+') 
    
Instructor Note

    
Note the use of the r modifier to create a raw string. This ensures that the backslashes inside the string are passed unchanged to the compile function. Using words, we can describe this regular expression as "one or more alphanumeric characters or periods, followed by an 'at' sign, followed by one or more alphanumeric characters or periods."
 
        
Python provides three ways to test for the presence of a regular expression in a string.

The first technique, match, will look for a regular expression at a specific point in a string. By default, match looks at the beginning of a string; the optional arguments pos and endpos allow you to focus on a substring.
search will find a regular expression anywhere within a string; to limit the search to a substring, the pos and endpos arguments are available.
Both search and match will either return a match object (if the regular expression was found in the string) or the special value None (if the regular expression was not found). Later in this module, I'll detail how you can access the information contained in the match object.

The third way to look for regular expression matches is findall. Unlike the other two methods, findall returns a list with all of the substrings within the string being tested that match the regular expression.
All three of these techniques can be used in two slightly different ways. If you've already compiled your regular expression, you can invoke the different techniques as methods; for an uncompiled regular expression, you can call the techniques as functions, with the regular expression as the first argument to the function.

Continuing with the e-mail pattern example, suppose we compile the regular expression and then invoke the search and findall methods, using a string that will generate a match.

>>> import re
>>> emailpat = re.compile(r'\w+@\w+.\w+')
>>> str = 'Contact me at myname@mydomain.com'
>>> emailpat.search(str)
<re.MatchObject instance at e8ca8>
>>> emailpat.findall(str)
['myname@mydomain.com'] 
Note that the search method returned a match object, while the findall method returned a list containing the substring that actually matched the regular expression.

If the regular expression is not compiled, search and findall can be called as functions.

>>> re.search(r'\w+@\w+.\w+',str)
<_sre.SRE_Match object at 0x013EFCD0>
>>> re.findall(r'\w+@\w+.\w+',str)
['myname@mydomain.com']
As its name implies, findall will return a list containing all of the matched substrings when there is more than one non-overlapping substring that matches a regular expression.

>>> newstr = 'My email addresses are myname@mydomain.org and
... othername@otherdomain.net'
>>> emailpat.findall(newstr)
['myname@mydomain.org', 'othername@otherdomain.net'] 

In the previous example, we constructed a regular expression that consisted of exactly the piece of text we wanted to extract, but in many situations, the text of interest may be embedded inside a regular expression. Consider extracting the names of images referenced in a Web page. An example of such a reference is

<img src="/images/back.gif"> 
When constructing a regular expression like this, it's important to take into account possible variations that will exist in practice. For example, the HTML standard allows blanks around keywords, has case-insensitive keywords, and allows either single or double quotes around filenames. To match any of the acceptable forms of the image reference, we could compile a regular expression as follows:

>>> imgpat = re.compile(r'''< *img +src *= *["'].+["']''',re.IGNORECASE) 
Since the regular expression contained single and double quotes, triple quotes were used; alternatively, to use single or double quotes, you would need to precede them with a backslash inside the regular expression. The construction of a blank followed by an asterisk represents zero or more blanks; the construction of a period followed by a plus sign represents one or more of any character (except newline). Finally, the IGNORECASE option is used to eliminate case sensitivity.

When we use a pattern like imgpat, we will extract the entire matching pattern; there's no easy way to grab just the name of the image itself. To make it easy to extract particular pieces of a regular expression, we can surround those pieces with parentheses, a process that is known as tagging.

Once we have tagged subexpressions inside a regular expression, we can extract the tagged expressions from a match object with the group or groups methods. In addition, when expressions are tagged in a regular expression, findall will return a list containing all the tagged expressions.

To extract just the image name from text using the imgpat regular expression, we must include parentheses around the part of the pattern that represents the image name (in this case, the .+ between the quotes).

Then, using findall, only the image names will be returned; if a match object is created (with search or match), then the group method would be invoked, using an argument of 1 to indicate that the first group is desired.

>>> imgtext = '<IMG SRC="../images/picture.jpg"><br> Here is a picture'
>>> imgpat = re.compile(r'''< *img +src *= *["'](.+)
["']''',re.IGNORECASE)
>>> m = imgpat.search(imgtext)
>>> m.group(1)
'../images/picture.jpg'
>>> imgpat.findall(imgtext)
['../images/picture.jpg'] 
    
Instructor Note

    
Note that findall returns a list, even when only a single pattern is found. When the group method is invoked with an argument of 0, the entire text that matched the regular expression is returned.
 
        
The ? Modifier

Suppose we use the imgpat regular expression on a string containing more than one image name.

>>> newtext = '<img src = "/one.jpg"> <br> <img src = "/two.jpg">'
>>> imgpat.findall(newtext)
['/one.jpg"> <br> <img src = "/two.jpg'] 
Instead of the expected result, the returned value started at the first image name and continued until the end of the second image name. The problem arises from the use of the + modifier in the regular expression. By default, the use of a plus sign (or an asterisk) in a regular expression causes Python to match the longest possible string that will still result in a successful match. Because the tagged expression (.) means "one or more of any character," Python continues to match the text until the final closing quotation mark is found.

To prevent this behavior, you can follow a plus sign or an asterisk in a regular expression with a ? modifier to let Python know that you want it to look for the shortest possible match instead of the longest possible match. With this modification, our regular expression returns the expected results.

>>> imgpat = re.compile(r'''< *img +src *= *["'](.+?)
["']''',re.IGNORECASE)
>>> imgpat.findall(newtext)
['/one.jpg', '/two.jpg'] 
Using (?:

We've seen that parentheses can be used to tag sub-expressions for later extraction. But parentheses are also used in constructing regular expressions. They allow you to group entities that will then be treated as a single entity. When you need to use parentheses for grouping, and you don't want them to tag sub-expressions, use the special sequence of three characters (?: to open the grouping parentheses. You can use an ordinary right parenthesis ()) to close the grouping.

Consider the problem of identifying numeric IP addresses within a string. A numeric IP address consists of four sets of numbers separated by periods. A regular expression to find these addresses could be composed as follows:

>>> ippat = re.compile(r'(?:\d+.){3}\d+')
>>> addrtext = 'Python web site: 132.151.1.190
... Google web site: 216.239.35.100'
>>> ippat.findall(addrtext)
['132.151.1.190', '216.239.35.100'] 
If we had used ordinary parentheses, only the last portion of the IP addresses would have been returned. Notice that it was necessary to use a backslash in front of the period, because we want the period to have its literal meaning, not its special meaning of "any character."

We've already seen that the findall method will return a list with multiple matches when they're present in a string. There are a few subtleties about the use of this method, as well as some alternatives that are useful in certain situations.

When you use findall with a regular expression that has tagged patterns, it will return a list of tuples containing the tagged patterns. There will be as many tuples as non-overlapping occurrences of the regular expression in the string being tested, and each tuple will have as many elements as there are tagged sub-expressions in the regular expression.

For example, consider matching a pattern consisting of a number followed by a word. To capture the number and word as separate entities, we can tag each of their sub-patterns.

>>> tstpat = re.compile(r'(\d+) (\w+)')
>>> tstpat.findall('29 blue')
[('29', 'blue')]
>>> tstpat.findall('29 blue 83 green')
[('29', 'blue'), ('83', 'green')] 
Even if there is only one occurrence of the tagged expressions, a tuple is still returned.

You can achieve more control over multiple matches within a string by using the match object returned by search or match. This object has, among other attributes, two methods called start and end, which return the indices in the matched string where the match was found. If these methods are called with an argument, they return the starting and ending indices of the corresponding tagged groups; without an argument, they return the indices for the entire match. Thus, by slicing the original string to remove matches as they are found, multiple matches can be processed one at a time.

To process the IP addresses in the previous example one at a time, we could use code like the following:

>>> addrtext  = 'Python web site: 132.151.1.90 
... Google web site: 216.239.35.100' 
>>> newtext = addrtext 
>>> ippat = re.compile(r'(?:\d+.){3}\d+') 
>>> mtch = ippat.search(newtext) 
>>> count = 1 
>>> while mtch: 
...    print('match %d: %s' % (count,mtch.group(0)))
...    count = count + 1 
...    newtext = newtext[mtch.end(0) + 1:] 
...    mtch = ippat.search(newtext) ...  
match 1: 132.151.1.90 
match 2: 216.239.35.100 
Like so many other features of Python, the choice of using findall or processing the match object is usually a personal one -- you just have to decide in a given setting which one will be the most useful.

In addition to finding regular expression pattern matches, the re module also lets you modify text based on the presence of regular expressions. In the simplest case, the sub function of the re module allows for simple text substitution.

>>> txt = "I love dogs. My dog's name is Fido"
>>> re.sub('dog','cat',txt)
"I love cats. My cat's name is Fido" 
Like other functions in the module, sub can be invoked as a method on a compiled regular expression object.

>>> ssnpat =  re.compile('(\d){3}-(\d){2}-(\d){4}')
>>> txt = 'Jones, Smith Room 419 SSN: 031-24-9918'
>>> ssnpat.sub('xxx-xx-xxxx',txt)
'Jones, Smith Room 419 SSN: xxx-xx-xxxx'
If you need to specify that any of the flags presented in the regular expression be substituted, you must use a compiled regular expression.

Note: the default behavior of sub is to substitute all occurrences of regular expressions found; you can pass an optional argument named count to sub to limit the number of substitutions it performs.

Substituting Tagged Patterns

When the regular expression to be substituted contains tagged patterns, these patterns can be used as part of the replacement text passed to sub. You can refer to the tagged patterns by preceding their number with a backslash; the first tagged pattern can be referred to as \1, the second as \2, and so on. For example, given text consisting of pairs of words followed by numbers, we can move the numbers before the words with a call to sub.

>>> txt = 'dog 13 cat 9 chicken 12 horse 8'
>>> re.sub('(\w+) (\d+)',r'\2 \1',txt)
'13 dog 9 cat 12 chicken 8 horse' 
This capability provides an easy way to eliminate unwanted text from a string. For example, suppose we have strings that contain the full pathname of a file, and we want to remove everything but the final part of the file name. By tagging the part we want and using the tagged part as the result of the substitution, we can extract the part we want.

>>> fname = '/usr/local/bin/python'
>>> re.sub(r'^.*/(.*)$',r'\1',fname)
'python' 
    
Instructor Note

    
When using this technique, it is essential that you use a raw string in the substituted text; otherwise, the backslashed numbers will be interpreted as octal constants.
 
        
Passing a Function to sub

For more complex substitutions, a function can be passed to sub in place of a replacement string. Each time a substitution is to be performed, Python passes an appropriate match object to this function and uses the return value of the function as the replacement text. Consider the task of changing decimal numbers to their hexadecimal equivalents in a string of text. The conversion itself is easy when we use Python's string formatting feature, the % formatting qualifier in particular.

>>> n = 12
>>> '%02x' % n
'0c' 
To make such a conversion part of a regular expression substitution, we need to write a function that will accept a match object, extract the number from this object, perform the conversion, and return the (string-valued) result. This function could then be passed to the sub function in place of a replacement.

The os module provides the simplest way to access information and programs from the operating system of the computer on which you're running Python.

This module contains a dictionary called environ, which has all the variables from the environment of the process that invoked Python. Because environmental variables are often used to convey information from the user, this dictionary is an easy way to access operating system information. In addition, you can change the value of elements in the environ dictionary, but remember that such changes will not be retained when you exit your Python program.

The system function in the os module accepts as its single argument any operating system command. The command is actually executed by the operating system, with its output going to its normal destination, generally the standard output stream.

The system function is not what returns the output of the executed command; the return value of system is an error code returned by the operating system. (When you need to manipulate the output of an operating system command, you can use the popen function of the os module, as explained in Topic 4.8.)

A few operating system tasks are so common that they are built into the os module as functions.

The listdir function accepts a single argument representing a directory (folder) and returns a list containing the names of all files and directories in that directory. Only the names of the files themselves, not the name of the containing directory, are returned, and the names of the files are presented in an arbitrary order. (Because functions in the os module, and operating system commands invoked through the system function, will resolve filenames relative to the current working directory when Python was invoked, it is sometimes useful to change the current working directory from within your Python program.)
The getcwd function allows you to retrieve the current working directory.
The chdir function allows you to change the working directory. Changes to the working directory made through the chdir command will only be in effect during the execution of the current Python process.
In addition to these commands, the os module contains commands for process management and low-level file manipulation. See the online documentation that was placed on your computer as part of the Python installation for more information. You can also check Python.org.


For working with filenames, the os module contains a sub-module named path. You never need to explicitly import the os.path module; simply import os and precede the name of the necessary function with os.path. Some of the functions in the os.path module are summarized in the table below. Each of the functions accepts a single argument that is the pathname in question.

Function Name
Purpose
Returns
abspath
Resolves a filename relative to the current working directory
Absolute pathname
basename
Returns the basename of a path
Basename
dirname
Returns the directory name of a path
Directory name
exists
Tests for existence of a path
1 if the path exists, 0 otherwise
expanduser
Expands tilde (~) paths
Expanded path (or original path if no tilde)
getsize
Returns the size of a file
Size of file in bytes
isfile
Tests for regular files
1 if path is a regular file, 0 otherwise
isdir
Tests for directories
1 if path is a directory, 0 otherwise
islink
Tests for links
1 if path is a link, 0 otherwise
In addition, the join function of the os.path module combines the pieces of a filename by using the appropriate pathname separator (/ for UNIX, \ for Windows, and :: for Macintosh).

Because the listdir function reports only the basenames of the files in a directory and doesn't include the directory itself, you must account for the containing directory in one of two ways.

One approach is to use the chdir function of the os module to change to the directory of interest before trying to access the files whose names are returned by listdir.
The join function of the os.path module to prepend the directory name to each filename returned by listdir. This approach is illustrated in the following example:
Suppose we want to write a function that will add together the sizes of all the files in a directory, excluding links and subdirectories. The following function is one implementation:

def sumfiles(dir): 
    files = os.listdir(dir) 
     
    sum = 0 
    for f in files: 
        fullname = os.path.join(dir,f) 
        if not os.path.isdir(fullname) and not os.path.islink(fullname): 
            sum = sum + os.path.getsize(fullname)
    return sum 
While they may not be as natural of an approach, the functional programming techniques described in Topic 6.5 also can be used on operations like the ones carried out by sumfiles above. Here's another implementation of this function using those techniques:

def sumfiles1(dir):
files = os.listdir(dir)
files =  map(os.path.join,[dir] * len(files),files)
files = filter(lambda  x:not os.path.isdir(x) and
not  os.path.islink(x),files)
sizes =  map(os.path.getsize,files)
return sum(sizes)
In the previous example, our program only added up the sizes of files in the current directory -- it didn't recurse through any subdirectories it encountered; it simply ignored them. While it would be possible to write a program that searches recursively all directories and subdirectories encountered in a target directory, for tasks like this, it's generally easier to use the os.walk function, which we'll discuss in the next topic.

Getting a list of files of a given directory is a common and useful task. We can perform various operations on each file, once we have this list. Python makes it easy with the os.walk function.

The os.walk function takes a directory as an argument and returns a directory tree from its top down (from the specified directory to its subdirectories).

The directory tree output is an iterator consisting of a 3-tuples. Each tuple contains the following:

the root directory
subdirectories in the current directory
files
The script below calculates the total size of all the files in the current directory as well as those in its subdirectories:

import os

total = 0     
for root, dirs, files in os.walk('.'):     
    size =  sum(os.path.getsize(os.path.join(root, file)) for file in files)
    total += size

print("Total Size of all Files:", total)
os.path.getsize returns the size of a given file (note that we need to pass the entire file path, not just the filename). The file path is constructed with os.path.join. The first argument to os.path.join is the root directory, followed by the filename. 
Using list comprehension, we generate a list of all the sizes of the files in the current directory. We then get the sum of all the sizes with the sum function.
As we iterate through each subdirectory, we get a new list of files. We keep track of the total with the total variable.

The shutil Module

The shutil module provides a number of functions that perform high-level file operations, such as copying and removing files or directories.

The copyfile function makes a copy of a single file. Its first argument is the file to be copied, and its second argument is the full name of the desired copy.
The copy command is similar to the copyfile command, but you can give a directory as the second argument.
The copytree command recursively copies an entire directory tree from one location (the first argument) to another (the second argument).
An optional third argument to copytree, named symlinks, controls how symbolic links are copied to the new location. If symlinks is true, symbolic links are created in the new directory tree; if symlinks is false or omitted, the copies of the actual files that are represented by links in the source directory are copied to the destination directory.

Finally, the rmtree function recursively removes an entire directory tree. It takes a single argument: the directory path to be removed.
    
Instructor Note

    
Remember when using the above functions that file names will be resolved relative to the current working directory of the Python process. This can be changed using the chdir function of the os module, or a directory name can be prepended to the filename using the join function of the os.path module.
 
        
The sys Module

Information about the current Python session is available through a variety of attributes of the sys module.

File objects corresponding to standard input, standard output, and standard error streams are available as variables named stdin, stdout, and stderr, respectively. You can use these file objects like any other file object to read and write to the standard streams.
The array argv contains any arguments that were passed to your Python program through the command line when the program was invoked. The first element of the array (sys.argv[0]) is the name of the script that is executing, and the remaining arguments (sys.argv[1:]) are additional arguments from the command line.
If you want to do standard option parsing of command line arguments, the getopt module is available to simplify the task.
The array path contained in the sys module contains the names of directories that will be searched by the import statement. You can examine this array to find the location of standard modules on your system.
The import statement will always find files in the current directory (provided they have a .py extension), but if you want to import a module from a non-standard directory, you can append the directory's name to the sys.path array. If you find yourself doing this regularly, you may want to set the PYTHONPATH environmental variable in a startup script to automatically include directories containing modules in the search path.
The function exit allows you to terminate a Python session. You can pass it an integer value, which will be passed to the operating system as an error code; a zero is generally used to indicate normal termination. Since your Python program will automatically terminate when your program completes, the only time you need to call exit is when you terminate abnormally, as we've seen in previous examples concerning exceptions.
The attribute exitfunc can be set to a function that will be called immediately before the Python interpreter exits. No arguments should be passed to the function stored in exitfunc.
The copy Module

As we've seen in Topic 5.1, assignments create references to objects and don't really create a new copy of an object in memory. You will recall that, given a list named x containing scalar values, you could create a true copy of x with either of the following statements:

      newx = x[:] 
      newx = copy.copy(x) 
If any or all of the elements of a list or dictionary that you're trying to copy are not scalars, however, the elements of the copied list corresponding to the non-scalar elements will simply be references to those non-scalar objects. In the case where you wish to make a true copy of a list with non-scalar elements, the deepcopy function of the copy module is available. This function recursively copies an object, using the actual values contained in the object, not references.

As a simple example, consider a list of lists. Notice what happens to the two copied objects, newx and deepx, when an element of one of the nested lists in the original object x is changed.

>>> x = [[1,2,3],['cat','dog','mouse','duck'],[7,8]] 
>>> newx = copy.copy(x) 
>>> deepx = copy.deepcopy(x) 
>>>  
>>> x[1][1] = 'gorilla' 
>>> newx[1][1] 
'gorilla' 
>>> deepx[1][1] 
'dog' 
Changes to lists nested in x are reflected in newx, since it simply contains references to those nested lists, while the corresponding value in deepx is unchanged.

    
Instructor Note

    
If an entire element of a list is changed, Python will realize that the copies are now the only objects referencing the original value, and the data will be preserved.
>>> x[2] = [107,108]
>>> newx[2]
7, 8]
>>> deepx[2]
[7, 8] 
 
        
In many situations, information to be processed is stored in a file, and you'll need to write a Python program to read that information. If the information in the file changes frequently, there's usually little choice but to read the contents of the file each time. But if the information doesn't change very often, it may be worthwhile to store the data in a file in a format that Python can read more easily than plain text.

Python provides two modules that are useful in this regard: pickle and shelve.

The pickle module allows you to store any Python object in a file, in a format that Python can quickly read back into memory. When you use a "pickled" object, much of the time a program spends reading in data can be eliminated. But unpickling a pickled object requires that the entire object be read into memory.

If you're dealing with very large amounts of data, the shelve module may provide a better alternative. Elements of a shelved object are only read into memory as needed -- the entire shelved object does not need to be read into memory in order to access its elements.

Of course, if you need features such as concurrency and the ability to perform advanced queries, you might be interested in Python interfaces to relational databases. But the shelve module provides easy access to a persistent, file-based version of an object that behaves very much like a dictionary.

    
Instructor Note

    
One limitation of the shelve module is that it only allows scalar string values to be used as keys. Any Python object can be used as a value corresponding to a key, however, because the shelve module uses pickle to store the objects themselves in the file it uses.
Nevertheless, these two modules can provide a simple alternative to using a full-fledged database in many situations.
 
        
The pickle Module

There are two steps to using the pickle module.

First, a Pickler object is created through a call to the Pickler function. You pass this function a file object, such as the one returned by the built-in open function.
Once a Pickler object is created, you can pass the name of the object you want to pickle to the dump method, which will write the pickled object to the file you specified when you created the Pickler object.
At this point, you can invoke the close method on the file object passed to Pickler, or you can let Python close the file when the program terminates.

As a simple example, consider a dictionary whose elements are dictionaries containing information about employees in a company. Of course, the real benefit of pickling comes when you are creating objects from some large, external data source, but this program will show the basic use of the module:

import pickle,sys
employees =  {    'smith':{'firstname':'fred','office':201,'id':'0001','phone':'x232'}, 
     'jones':{'firstname':'sue','office':207,'id':'0003','phone':'x225'}, 
     'williams':{'firstname':'bill','office':215,'id':'0004','phone':'x219'}  }
try: 
     f =  open('employees.dump','wb') 
except IOError: 
     sys.stderr.write('Error opening employees.dump for write') 
     sys.exit(1)
pkl = pickle.Pickler(f) 
pkl.dump(employees) 
f.close() 
When the employee dictionary is needed in another program, all we need to do is open the file containing the pickled object and use the load function of the pickle module.

>>> import pickle
>>> f = open('employees.dump','rb')
>>> employees = pickle.load(f)
>>> employees['jones']['office']
207
>>> employees['smith']['firstname']
'fred' 
The shelve Module

To create a shelve object, use the open method of the shelve module, passing the name of a file that will be used to hold the shelve object. You should be aware that Python may create more than one file in the process of creating a shelve object. But, provided the additional files are not removed, Python will always find your object if you pass the same name to the open method as you used when you created the shelve object.

If you specify a file that already exists but is not a shelve object, the module raises an anydbm.error exception; otherwise the open function will recognize a previously created shelve object and open it.

    
Instructor Note

    
Because information is written to the shelved object only when necessary, it's important to explicitly invoke the close method on any shelved object you use, to ensure that changes you make during your program are properly stored.
 
        
Here's the employee example revisited, using a shelve object. While there's not much advantage in shelving over pickling for such a small data set, it will illustrate the basic ideas of using a shelve object.

>>> import shelve 
>>> employees =  
...     { 'smith':{'firstname':'fred','office':201,'id':'0001','phone':'x232'}, 
...     'jones':{'firstname':'sue','office':207,'id':'0003','phone':'x225'}, 
...     'williams':{'firstname':'bill','office':215,'id':'0004', 
...     'phone':'x219' } }
>>> try: 
...     emp = shelve.open('employees.dat') 
... except IOError: 
...     sys.stderr.write('Error opening employees.dat') 
...     sys.exit(1) 
...  
>>> for k in employees.keys(): 
...     emp[k] = employees[k] 
...  
>>> emp.close() 
When we need to access the shelved data, we simply open the appropriate file, and the data will be available.

>>> import shelve
>>> employees = shelve.open('employees.dat')
>>> employees['jones']['office']
207
>>> employees['smith']['firstname']
'fred' 

When you type a URL representing the address of a Web page into a browser, a request is made to a computer on the Internet to send the contents of some file, generally written in HTML, to your computer. Your Web browser knows how to display it as text, pictures, links, animations, or whatever else the designer of the Web page had in mind.

Alternatively, the address that your browser requests might be a program. In that case, that program will be run on the Web site's computer, and the results of the program will be transmitted to your Web browser. You can provide information to that program through the use of forms or specially formatted URLs that enable online shopping, surveys, e-mail programs, and other useful tools.

CGI (Common Gateway Interface) is the name given to the mechanism used to transmit information to and from your Web browser and a Web site's computer. The cgi module provides a way for you to retrieve this information and to send HTML back in response to a submitted form.

Besides using a fill-in form displayed in a browser to retrieve information, a specialized type of URL can be used to transmit information to a CGI program. The program's name is followed with a question mark and then a series of name-value pairs, separated from each other by ampersands. For example, a URL to query a travel agency might look like

http://www.travelagency.com/cgi-bin/query?dest=Costa%20Rica&month=Jun&day=12 
This URL, when received by the query program on the travel agency's Web server, would create three CGI variables.

dest with a value of Costa Rica
month with a value of Jun
day with a value of 12
    


    
A non-alphanumeric character, like a blank, must be encoded as a percent sign followed by two digits. As an alternative to such a URL, the values of these variables could be set through a form displayed in a Web browser by using scrolling lists, drop-down menus, or blanks to be filled in.
 
        
The FieldStorage Object

When you use a Python script as a CGI program, you create a FieldStorage object by using the FieldStorage function of the cgi module. This object behaves like a dictionary in many ways. For example, you can use the keys method to get a list of all the variables that were sent to your program.

When you index the FieldStorage object with the name of any valid CGI variable, Python returns a MiniFieldStorage object, which has two attributes: name and value. Thus, if the following Python program were properly installed on the fictitious travel bureau's Web server, it would print the destination, month, and day specified in the URL.

import cgi
f = cgi.FieldStorage()
print("Content-type: text/html")
print()
vars = f.keys() 
for v in vars: 
   print('%s = %s' % (v,f[v].value))  
The other way to transmit information to a CGI program is through a form that appears in the user's browser.

Submit Query

The URL of the CGI program should appear in the action element of the <form> tag. The following HTML code will display a simple form to transmit the same information as was transmitted through the URL in the previous example. When the user presses the Submit button, the CGI script in the previous example will receive the information; the FieldStorage object will be created appropriately whether the input comes from a URL or through a form.

<html> 
<body> <form method="post" action="/cgi-bin/query"> Destination <input type="text" name="dest" size=40> Month <select name=month> 
<option>Jan<option>Feb<option>Mar<option>Apr<option>May 
<option>Jun<option>Jul<option>Aug<option>Sep<option>Oct 
<option>Nov<option>Dec</select> Day <select name=day> 
<option>1<option>2<option>3<option>4<option>5<option>6<option>7 
<option>8<option>9<option>10<option>11<option>12 <option>13 
<option>14<option>15<option>16<option>17<option>18<option>19 
<option>20<option>21<option>22<option>23<option>24<option>25 
<option>26<option>27<option>28<option>29<option>30<option>31 </select> 
<center> <input type=submit> </center> </form> </body> </html> 
Environmental Variables

In addition to information that is transmitted through CGI variables (such as dest, month, and day in the previous example), a large amount of information is transferred to CGI programs through environmental variables. These variables can be accessed in your program in the usual way -- by using the environ dictionary of the os module. The table below lists the names and meanings of some of these environmental variables.

Name
Contents
HTTP_COOKIE
Persistent data stored in cookies
HTTP_REFERER
URL of referring document
HTTP_USER-AGENT
Type of browser being used
QUERY_STRING
URL fragment after ?
REMOTE_ADDR
IP address of user
REMOTE_HOST
Hostname of user
REMOTE_USER
Username, if authentication was used
SERVER_NAME
Hostname of server
SERVER_PORT
Port number of server
SERVER_SOFTWARE
Name and version of server software


The urllib module is useful for developing applications that act as clients to the Internet. While Python can be written to write full-scale browsers (see the Grail project), the urllib module is most useful when writing applications that try to automate interaction with the Web.

urllib is divided into the following sub libraries:

urllib.request
URL opening library
urllib.response
Response classes used internally by urllib. These are not called directly.
urllib.parse
Parse URLs into or assemble them from components
urllib.error
Exception classes raised by urllib.request
We will focus mainly on the urllib.request and urllib.parse.

The core of the urllib.request module is the urlopen function. This function accepts a URL as an argument and returns a file-like object that allows you to access the contents of the URL using any of the standard file methods (read, readline, or readlines). (You can review the details on these methods in Module 4, Topic 4.3.)

An optional second argument is a URL-encoded string, which provides data to be sent to the URL if it is a CGI program. (If the URL provided does not begin with http:// or ftp://, the request is treated as a local file.) Later on in this topic, we'll take a closer look at urllib.parse’s urlencode function that creates this string.

Using the urlopen and urlencode Functions

As a simple example of the use of the urlopen function, we will extract the title of a given URL’s web page. By convention, web page titles are enclosed within HTML title tags (<title> and </title>). Note that some websites may choose to put something other than a title between the tags. We can write a regular expression to extract the title.

titlepat = re.compile('<title>(.*)</title>',re.I)
All that remains is to access the contents of the page with the urllopen function.

def get_webtitle(url):
     titlepat =  re.compile('<title>(.*)</title>',re.I)
     try: 
        f =  urllib.request.urlopen(url)
     except IOError: 
        sys.stderr.write("Couldn't connect to %s " % url) 
        sys.exit(1)
     contents =  str(f.read())
     f.close()
     title =  titlepat.findall(contents)
 return title[0]
Because findall returns a list, only the first element of the list is printed.

You can also use the urlopen function to post data to a CGI program. The information to be posted can either be embedded in the URL itself, or it can be sent to the URL through headers. In the first case, it is important that special characters (blanks, punctuation, and so on) are converted to the appropriate codes using the quote function of the urllib.parse module. In the second case, the urlencode function accepts a dictionary of values and converts them to the appropriate form.

>>> travelplans = {'dest': 'Costa Rica','month':  'Jun','day' : 25 }
>>> urllib.parse.urlencode(travelplans)
'month=Jun&day=25&dest=Costa+Rica' 
We could contact the fictitious travel agency CGI program with a program like this one:

urllib.request.urlopen('http://www.travelagency.com/cgi-
bin/query', urllib.parse.urlencode(travelplans)) 
As a more realistic example, we will retrieve the short description of a Python module from the Python website. To display the full description of a Python module

http://docs.python.org/3.0/library/modulename.html
Examination of the HTML text returned by this URL shows that the description of the module comes after an HTML dash (HTML code &#8212;) and ends just before an anchor tag (<a>). We can extract the short description of the module with the following function:

import sys,re
import urllib.request

def get_moduledesc(modulename):
    moduledescline =  re.compile('&#8212; (.*)<a')
    url = 'http://docs.python.org/3.0/library/%s.html'  % modulename
    try:
        f =  urllib.request.urlopen(url)
    except  urllib.error.HTTPError:
        sys.stderr.write("Could not find module:%s\n" % modulename) 
        sys.exit(1)
    description = ''

    while 1:
        line =  str(f.readline())
        if not line : break
        description =  moduledescline.findall(line)
        if (description):
            break;
    return description[0] 
 (Note that our function above might not work if the word does not exist or if the site changes its format or layout.)

The syntax of the URLs accepted by urlopen allows embedding a username-password pair or optional port number in the URL. Suppose we want to access the site http://somesite.com by using user name myname and password secret, through port 8080 instead of the usual default of 80. The following call to urlopen could be used:

       urllib.request.urlopen('http://myname:secret@somesite.com:8080') 


----- 10

In Python, a module is simply a file that contains Python code and can be imported into some other program. Thus, if you have a collection of functions that you'd like to use in other Python programs, you can simply put them all in one file, say myfunctions.py, and use the import statement to make those functions available to you.

If your module is located in your working directory, Python will always find it. Otherwise, it must be located in Python's search path. You can view the search path with the following Python statements:

import sys
sys.path 
Because sys.path is just a list, you can append the names of other directories to search onto this list before using an import statement. This allows you to access modules that are not on the search path. But if you keep your modules in one location, a more useful approach may be to set the PYTHONPATH environmental variable to that location in the appropriate start-up file for your operating system. That way, all the Python programs you run will be able to use your modules.


As a simple example of a module, we'll write three functions that would be useful if you were working with files. We will call this module fileutils.

The first, which we'll call lline, will return the length of the longest line encountered in a file.
The second, which we'll call wcount, will be a Python version of the UNIX command wc, which, given a file name, returns the number of lines, words, and characters contained in the file.
The final function, which we'll call ccount, will count the number of occurrences of a given character in a file.
To make these functions available for use in programs, we'll store the Python code for these three functions in a file called fileutil.py, in either the current directory or one of the directories in the Python search path. The following code implements these three functions:

def lline(filename): 
    f = open(filename,'r') 
    longest = 0 
    while 1: 
        line = f.readline() 
        if not line: 
            break 
        lennow = len(line) - 1 
        if lennow > longest: 
            longest = lennow 
    f.close() 
    return longest
def wcount(filename): 
    f = open(filename,'r') 
    nlines = nwords = nchars = 0 
    while 1: 
        line = f.readline() 
        if not line: 
            break 
        nlines = nlines + 1 
        nwords = nwords + len(line.split()) 
        nchars = nchars + len(line) 
    f.close() 
    return (nlines,nwords,nchars)
def ccount(filename,char='\t'): 
    f = open(filename,'r') 
    found = 0 
    while 1: 
        line = f.readline() 
        if not line: 
            break 
        found = found + line.count(char) 
    f.close() 
    return found 
In the lline function, the length of a line is calculated as one less than the value returned by the len function. That is because the len function counts the newline character as part of the line, whereas most users think of the length of a line as the number of characters in the line, not including the newline.

You may have noticed that, although there are calls to open in the functions in the fileutils module, the usual practice of enclosing them in a try/except clause has not been followed. The reason: there is very little the functions can do if they cannot open the files, so the burden is placed on the caller of the program to enclose the call to these functions in a try/except clause. That way they can deal with whatever exceptions are raised. The issue of exceptions should be a consideration in the design of any module.

Note that in the ccount function, an arbitrary choice was made to use the tab as the default character to be counted. It is generally very convenient to provide default values for arguments to functions, and, like the exceptions problem, you should give some thought to the issue of defaults when you create functions like these.

Suppose the file containing the function definitions is called fileutils.py. If the Python search path (sys.path) contains the directory in which fileutils.py is found, we can access these functions in the following way:

    #!/usr/local/bin/python
    import sys,fileutils
    for file in sys.argv[1:]:
        ll = fileutils.lline(file)
        if ll > 80: 
            print('Long line (%d chars) found  in %s' % (ll,file)) 
Individual functions could be imported from fileutils in the usual way. In fact, once you've written a module in Python, and that module's directory is on the Python search path, there's very little difference between a user-written module and a module that's a part of Python itself.

If you're developing a set of functions, it's a very good idea to write a program that tests each function, especially if you'll be modifying the functions over time. One way to create a test function is to simply write a program and store it in a file separate from the file with your functions. However, Python provides a convenient way to keep your test program in the same file as the module itself.

Remember that when you import a module into a Python program, the contents of the module are executed when the import statement is encountered. Thus, you can't just include your test program in your module, or it will be executed every time the module is imported. But Python provides a built-in variable called __name__, which will be equal to the name of a module when the module is imported but will be equal to the value "__main__" when a program is executed directly. Thus, we could include a test program for the fileutils module by including the following lines in the file strfunc.py after the function definitions:

    if  __name__ == '__main__': import sys 
        files = sys.argv[1:] 
        for f in files: 
            print('Processing %s' % f)
            print(' Longest line is %d characters' % lline(f))
            print(' File contains %d lines, %d words, and  %d characters' % wcount(f))
            print(' The file contains %d spaces' %  ccount(f,' '))
            print() 
Now when the program is invoked directly (for example, through the execfile function or by typing the program's name at a shell prompt), the test program will be run, but when the module is imported into another program, the test program is ignored. In this program, the sys module is not needed for the functions defined in the module, so the import statement for that module was placed after the if statement that checks for the value of __name__.


Creating a module with a set of functions to perform useful tasks is certainly an effective way to approach many problems. If you find that this approach can solve all your problems, you may be content to use it and not explore other ways of getting things done. However, Python provides a simple method for implementing object-oriented programming through the use of classes.

We've already taken advantage of object orientation through the methods available for manipulating lists, dictionaries, and file objects. File objects in particular show the power of these techniques. Once you create a file object, it doesn't matter where it came from when you want to, say, read a line from such an object. You simply invoke the readline method. The ability to do what you want without having to worry about the internal details is a hallmark of object-oriented programming.

The main tool in Python for creating objects is the class statement. When you create a class, it can contain variables (often called attributes in this context) and methods. To actually create an object that you can use in your programs, you invoke the name of its class. In object-oriented lingo, we say that the class name serves as a constructor for the object.

Methods are defined in much the same way as functions, with one small difference. When you define a method, the first argument to the method should be called self, and it represents the object upon which the method is acting. Even though self is in the argument list, you don't explicitly pass an object name through this argument. Instead, as we've seen for built-in methods, you follow the name of the object with a period and the method name and argument list.

Operator Overloading

Besides creating methods of our own, we can change the meaning of the way many familiar operators work, a technique known as operator overloading. Special methods, whose names begin and end with double underscores, can be defined to "intercept" many common operators, allowing you to redefine what such operators as print, +, and *, or functions such as len will do when they're applied to the objects you create.

One of the most important operator overloading methods is __init__, which is called whenever the class name is used as a constructor. It allows you to initialize attributes in your object at the same time that you create it.

The __str__ method is called through the print statement; the __repr__ method is called when an object's name is typed in the interpreter. The table below lists these and some of the other commonly used methods for overloading.

Method
Use
__init__(object)
Called when class constructor is invoked
__repr__(object)
Also called when object name is typed in interpreter
__del__(object)
Called when an object is destroyed
__str__(object)
Called by print(object)
__len__(object)
Called by len(object)
__getitem__(object,key)
Allows you to intercept subscripting requests
__setitem__(object,key,value)
Allows you to set values of subscripted items
__getslice__(object,start,fin)
Allows you to intercept slice requests
__setslice__(object,start,fin,value)
Allows you to set slices
__add__(object,other)
Called by object + other
__radd__(object,other)
Called by other + object
__sub__(object,other)
Called by object - other
__mul__(object,other)
Called by object * other
__mod__(object,other)
Called by object % other
To clarify these ideas, during the next two commentary topics we'll consider a simple example -- a database of phone numbers and e-mail addresses.

To get started with designing a class, it's often easiest to first think about the information you're going to manipulate when you eventually operate on that class. You don't need to think of everything the first time you create the class. One of the many attractive features of working with classes is that you can easily modify them as you get deeper into solving a problem.

In the case of our database, the basic information we'll be storing will be a name, a phone number, and an e-mail address. We'll call the class that will hold this information Friend, and when we actually store our information, it will be in what is generically known as an object; in this case a Friend object. We can define methods by indenting their definitions under the class statement.

When we create a Friend object, all we need to do is store the name, phone number, and e-mail address of a friend, so the __init__ method will be very simple -- we just need to create three attributes, which we'll call name, phone, and email. This object will serve as a building block for our database, so we don't need to define many other methods. As an example, we'll create a __str__ method and an identical __repr__ method so that we can display information about our friends in a readable format.

>>> class Friend: 
...     def __init__(self,name,phone='',email=''): 
...             self.name = name 
...             self.phone = phone 
...             self.email = email 
...     def __str__(self): 
...             return 'Name: %s\nPhone: %s\nEmail: %s' % (self.name,self.phone,self.email)
...     def __repr__(self): 
...             return self.__str__() 
...  
>>> x = Friend('Joe Smith','555-1234','joe.smith@notmail.com') 
>>> y = Friend('Harry Jones','515-2995','harry@who.net') 
>>> print(x) 
Name: Joe Smith 
Phone: 555-1234 
Email: joe.smith@notmail.com 
>>> y 
Name: Harry Jones 
Phone: 515-2995 
Email: harry@who.net 
Just as with functions, we can provide default values for arguments passed to methods. In this case, name is the only required argument; the other two arguments default to empty strings. Notice that attributes are referred to as self.name. Without the leading self, variables will be treated as local and will not be stored with the object. Finally, notice that the print operator as well as the interactive session's default display have been overridden with the __str__ and __repr__ methods, respectively.

Now, through the Frienddb class, we can create a database containing information about our friends. To make it useful, we'll introduce persistence through the cPickle module, which you'll remember from Topic 9.5.

When we first create the database, we'll require the name of a file. If the file exists, we'll assume it's a database we've already created and work with that. If the file doesn't exist, we'll open it and prepare it to receive our pickled database. For this simple application, we can simply create a list of Friend objects and store the list as an attribute in our Frienddb object.

When designing an object-oriented application like this, we simply need to identify the operations we'll want to do on the object we've created. In addition to the __init__ method, some of the tasks we'd want to implement would be

adding a new friend to the database
searching the database for information about a particular person
storing the database when we're done with it
In the material below, it's assumed that the class definition for Friend is either in the same file as the Frienddb definition or has been properly imported along with the other appropriate modules (os, cPickle, sys, re, and string). In addition, the following class statement will have appeared before the definition of these methods:

class Frienddb: 
The __init__ method for our database will take care of all the dealings with the file in which the database will be stored.

import os, sys, string, re, pickle

class Frienddb: 
    def __init__(self,file=None): 
        if file == None: 
            print('Must provide a filename') 
            return  
        self.file = file 
        if os.path.isfile(file): 
            try: 
                f = open(file,'rb') 
            except IOError: 
                sys.stderr.write('Problem opening file %s' % file) 
                return 
            try: 
                self.db = pickle.load(f) 
                return 
            except pickle.UnpicklingError: 
                sys.stderr.write('Not a pickled database') 
                return 
            f.close() 
        else: 
            self.db = [] 
Because the __init__ statement acts as a constructor for class objects, it should never return a value. Thus, when errors are encountered, a return statement with no value must be used. This method puts two attributes into our Frienddb object: file, the name of the file to store the database, and db, the list containing Friend objects (if the database already exists) or an empty list if there is not a file with the name passed to the method.

Adding an Entry

The method for adding an entry to the database is simple.

def add(self,name,phone='',email=''): 
    self.db.append(Friend(name,phone,email)) 
Searching

Searching the database is a little more complex. We'll use the re module to allow regular expression searches and return a list of Friend objects whose name attributes match the pattern that is provided. Because we'll be searching each name in the database, the regular expression is compiled before being used.

def search(self,pattern): 
    srch = re.compile(pattern,re.I) 
    found = [] 
    for item in self.db: 
        if srch.search(item.name): 
            found.append(item) 
    return found 
Storing

Finally, we'll write methods to store the contents of the database into the file that was specified when the database was created. This is just a straightforward use of the cPickle module. To ensure that data is not lost, a __del__ method that simply calls the store method (provided that there were entries in the database) will be added as well.

def store(self,file=None): 
        try: 
            f = open(self.file,'wb') 
        except IOError: 
            sys.stderr.write('Problem opening file %s for write' % self.file) 
            return 
        p = pickle.Pickler(f,1) 
        p.dump(self.db) 
        f.close() 
     
def __del__(self): 
        if self.db: 
            self.store() 
Having created these two classes, we can now write a simple program to use them. This program could be included in the same file as the class and method definitions (fileutils.py in our module example in Topic 10.3), or it could be stored as a separate file.

The program will be an interactive loop that will recognize three commands.

a, which will cause the program to prompt for a name, phone number, and e-mail address and then add it to the database
? pattern, which will print all the records whose name attribute matches pattern
q, which will store the database and exit
In the program, I'm assuming that the class definitions for Friend and Frienddb are stored in a file called frienddb.py, which is in a directory on the Python search path.

import frienddb 
file = input('File? ') 
fdb = Frienddb(file) 
     
while 1: 
    line = input('> ') 
    if line[0] == 'a': 
        name = input('Name? ') 
        phone = input('Phone number? ') 
        email = input('Email? ') 
        fdb.add(name,phone,email) 
    elif line[0] == '?': 
        line = string.strip(line[0]) 
        fdb.search(line) 
    elif line[0] == 'q': 
        fdb.store() 
        break 

The concept behind operator overloading is that, in addition to defining methods that will operate on the classes we create, we can also redefine the meaning of such operations as +, -, /, and indexing.

For our Frienddb example, we'll redefine the idea of indexing so that we can access elements of our database either by a numeric index (indicating their position in the database) or by the name attribute of the individual records. To do this, we define a __getitem__ method that will accept an index, which the user will enclose in square brackets after the Frienddb object's name, and which will return the appropriate element of the database.

To properly process both string and numeric indices, we'd need to distinguish between those two types of values. A way to do this is by trying a numeric conversion of the index with the int function; if an exception is thrown, then we must have a string value.

The following method, which would be included within the class definition, allows both numeric and string indices to be used when subscripting a Frienddb object:

def __getitem__(self,key): 
    try: 
        index = int(key) 
        return self.db[index] 
    except ValueError: 
        found = 0 
        for item in self.db: 
            if item.name == key: 
                found = 1 
                return item 
        if not found: 
            raise KeyError(key) 
If a string is given, and no record with that name is found, the method simply raises the built-in KeyError exception, allowing the caller of the method to decide how to handle this case.

Having implemented the __getitem__ method, we can now access the elements of the database using subscripts.

>>> import frienddb 
>>> fdb = frienddb.Frienddb('friend.db') 
>>> fdb[0] 
Name: Harry Smith 
Phone: 443-2199 
Email: hsmith@notmail.com 
>>> fdb[1] 
Name: Sue Jones 
Phone: 332-1991 
Email: sue@sue.net 
>>> fdb['Harry Smith'] 
Name: Harry Smith 
Phone: 443-2199 
Email: hsmith@notmail.com 

One of the biggest benefits of the class-based approach to programming is that classes can inherit attributes and methods from other classes. If you need to work with an object that's very similar to some other object that has already been developed, your new object can inherit all of the old object's methods, add new ones, and/or overwrite the ones that need to change.

Continuing with our database example, suppose that we find the friend database so useful at home that we want to extend it into a database to keep track of business contacts. It would be very helpful to have a few additional fields in the database -- let's say a company name and the type of product that the company produces. Following the example of the Friend object, you could create a Contact object as follows:

class Contact: 
    def __init__(self,name,company,phone='',email='',product=''): 
        self.name = name 
        self.company = company 
        self.phone = phone 
        self.email = email 
        self.product = product
    def __str__(self): 
        return 'Name: %s: %s: %s: %s: %s' %  
               (self.name,self.company,self.phone,self.email,self.product) 
                
              
    def __repr__(self): 
        return self.__str__() 
Now we'd like to create an object that would let us store, add to, and search a database of contacts. The details of opening files, pickling, searching, and indexing really haven't changed -- our Contactdb object can simply inherit all of them from the Frienddb object. The only real change is that now we'll be storing Contact objects in the list called db inside of the object instead of Friend objects, so we'll need to overwrite the add method.

from frienddb import Frienddb
class Contactdb(Frienddb): 
    def add(self,name,company,phone='',email='',product=''): 
        self.db.append(Contact(name,company,phone,email,product)) 
By putting the name of another class (Frienddb) in parentheses after the name of our new class (Contactdb), we're informing Python that this class will inherit methods and attributes from that old class. If we invoke a method or try to access an attribute that's been explicitly defined for our new class, Python will use the one we've defined. But if we refer to a method or attribute we haven't explicitly defined, it will refer to that method or attribute in the so-called "parent" class.

    
Instructor Note

    
Python even supports multiple inheritance; if you have a comma-separated list of classes in parentheses after your class name, Python will search each of them in turn for methods or attributes not explicitly defined for the new class.
 
        
Now, after defining the add method, we can create and use our contact database in a manner almost identical to the friend database.

>>> import contactdb 
>>> fdb.search('harry') 
[Name: Harry Smith 
Phone: 443-2199 
Email: hsmith@notmail.com] 
>>> cdb = contactdb.Contactdb('new.db') 
>>> cdb.add('Mary Wilson','Brainpower, Inc.','222-3292', 
...     'mw@brainpower.net','consulting') 
>>> cdb.add('John Jenkins','Advanced Microstuff','321-9942', 
...     'jjenkins@advmicro.com','disk drives') 
>>> cdb.add('Fred Smith','Hitech Storage','332-1994', 
...     'fredsmith@hitechstorage.com','magnetic tape') 
>>> cdb.add('Al Watson',"Brains 'r Us",'335-2324', 
...     'al@brains.net','consulting') 
>>> cdb.search('mary') 
[Name: Mary Wilson 
Company: Brainpower, Inc. 
Phone: 222-3292 
Email: mw@brainpower.net 
Product: consulting] 
>>> cdb[3] 
Name: Al Watson 
Company: Brains 'r Us 
Phone: 335-2324 
Email: al@brains.net 
Product: consulting 
>>> cdb['John Jenkins'] 
Name: John Jenkins 
Company: Advanced Microstuff 
Phone: 321-9942 
Email: jjenkins@advmicro.com 
Product: disk drives                                                   
All of the methods we implemented for the Frienddb class work correctly with our new class. Since we defined a Contact object and explicitly defined an add method to use it, Python knows how to display the contacts properly.

Now suppose that we want to expand the search method to allow us to specify, using a keyword argument, whether we wish to search the database for a name, a company, or a product. We've already developed a method to search for names when we wrote the Frienddb class, so we can use that when we're searching for names and add additional code to handle the other cases. When you need to access a method from another class, you need to treat the method like a regular function. In other words, instead of following self with the method name, you call the function with self as the first argument to the method, as illustrated below, when the search method from the Frienddb class is invoked in our new search method.

def search(self,name='',company='',product=''): 
results = [] 
if name: 
      found = Frienddb.search(self,name) 
      results.extend(found)
if company: 
      srch = re.compile(company,re.I) 
      found = [] 
      for item in self.db: 
          if srch.search(item.company): 
              found.append(item) 
      results.extend(found) 
             
if product: 
      srch = re.compile(product,re.I) 
      found = [] 
      for item in self.db: 
          if srch.search(item.product): 
              found.append(item) 
      results.extend(found)
return results 
(As in previous examples, this method would only make sense if it was part of the definition for the class Contactdb.)

Now we can search for names, companies, or products.

>>> cdb = contactdb.Contactdb('new.db')       
>>> found = cdb.search(product='consult') 
>>> for i in found: 
...     print('-' * 10) 
...     print(i) 
... 
---------- 
Name: Mary Wilson 
Company: Brainpower, Inc. 
Phone: 222-3292 
Email: mw@brainpower.net 
Product: consulting 
---------- 
Name: Al Watson 
Company: Brains 'r Us 
Phone: 335-2324 
Email: al@brains.net 
Product: consulting 
>>> found = cdb.search(name='mary') 
>>> print(found[0]) 
Name: Mary Wilson 
Company: Brainpower, Inc. 
Phone: 222-3292 
Email: mw@brainpower.net 
Product: consulting                              






